// Generated by CoffeeScript 1.12.4
(function() {
  'use strict';
  var CND, IDLX_GRAMMAR, IDL_GRAMMAR, Idl_lexer, NCR, NEARLEY, PATH, _condense, _registry_from_grammar, badge, condense, debug, echo, help, info, log, operators_from_paths, paths, rpr, urge, warn, whisper;

  PATH = require('path');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'NEARlEY';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  NEARLEY = require('nearley');

  IDL_GRAMMAR = require('./idl');

  IDLX_GRAMMAR = require('./idlx');

  NCR = Object.create(require('ncr'));

  NCR._input_default = 'xncr';

  NCR.jzr_as_uchr = function(glyph) {
    if ((this.as_csg(glyph)) === 'jzr') {
      return this.as_uchr(glyph);
    }
    return glyph;
  };

  NCR.jzr_as_xncr = function(glyph) {
    var nfo;
    nfo = this.analyze(glyph);
    if (!((nfo.rsg === 'u-pua') || (nfo.csg === 'jzr'))) {
      return glyph;
    }
    return this.as_chr(nfo.cid, {
      csg: 'jzr'
    });
  };

  Idl_lexer = function() {
    this.reset('');
    return null;
  };

  Idl_lexer.prototype.reset = function(data, state) {
    this.buffer = NCR.chrs_from_text(data, {
      input: 'xncr'
    });
    this.index = 0;
    this.line = state ? state.line : 1;
    this.prv_nl = state ? -state.col : 0;
    return null;
  };

  Idl_lexer.prototype.next = function() {
    var chr;
    if (this.index < this.buffer.length) {
      chr = NCR.jzr_as_uchr(this.buffer[this.index]);
      this.index += +1;
      if (chr === '\n') {
        this.line += +1;
        this.prv_nl = this.index;
      }
      return {
        value: chr
      };
    }
    return null;
  };

  Idl_lexer.prototype.save = function() {
    return {
      line: this.line,
      col: this.index - this.prv_nl
    };
  };

  Idl_lexer.prototype.formatError = function(token, message) {
    var R;
    R = message + " at index " + (this.index - 1) + " (" + (this.buffer.join('')) + ")";
    return R;
  };

  this.IDL = {};

  this.IDL.parse = function(source) {
    var R, type;
    if ((type = CND.type_of(source)) !== 'text') {
      throw new Error("expected a text, got a " + type);
    }
    if (source.length === 0) {
      throw new Error("expected a non-empty text, got an empty text");
    }

    /* TAINT should we rewind()? finish()? parser? */
    this._parser = new NEARLEY.Parser(IDL_GRAMMAR.ParserRules, IDL_GRAMMAR.ParserStart, {
      lexer: new Idl_lexer()
    });
    this._parser.feed(source);
    if (this._parser.results.length !== 1) {
      throw new Error("Syntax Error: " + (rpr(source)));
    }
    R = this._parser.results[0];
    if (R.length === 1) {
      R = R[0];
    }
    return R;
  };

  this.IDLX = {};

  this.IDLX.parse = function(source) {
    var R, type;
    if ((type = CND.type_of(source)) !== 'text') {
      throw new Error("expected a text, got a " + type);
    }
    if (source.length === 0) {
      throw new Error("expected a non-empty text, got an empty text");
    }

    /* TAINT should we rewind()? finish()? parser? */
    this._parser = new NEARLEY.Parser(IDLX_GRAMMAR.ParserRules, IDLX_GRAMMAR.ParserStart, {
      lexer: new Idl_lexer()
    });
    this._parser.feed(source);
    if (this._parser.results.length !== 1) {
      throw new Error("Syntax Error: " + (rpr(source)));
    }
    R = this._parser.results[0];
    if (R.length === 1) {
      R = R[0];
    }
    return R;
  };

  condense = function(grammar) {
    var paths, registry;
    registry = _registry_from_grammar(grammar);
    paths = new Set();
    _condense(registry, new Set(), paths, grammar.ParserStart);
    return Array.from(paths);
  };

  _registry_from_grammar = function(grammar) {
    var R, entry, i, j, len, len1, name, ref, rule, symbol, symbols, target;
    R = {};
    ref = grammar.ParserRules;
    for (i = 0, len = ref.length; i < len; i++) {
      rule = ref[i];
      name = rule.name, symbols = rule.symbols;
      for (j = 0, len1 = symbols.length; j < len1; j++) {
        symbol = symbols[j];
        if (CND.isa_pod(symbol)) {
          symbol = '"' + symbol.literal + '"';
        }
        entry = R[symbol] != null ? R[symbol] : R[symbol] = [];
        target = R[name] != null ? R[name] : R[name] = [];
        target.push(symbol);
      }
    }
    return R;
  };

  _condense = function(registry, seen, paths, name, route) {
    var entry, i, is_public_name, len, path, symbol, symbols;
    if (route == null) {
      route = [];
    }
    if (seen.has(name)) {
      return;
    }
    seen.add(name);
    symbols = registry[name];
    is_public_name = !/\$/.test(name);
    if (is_public_name) {
      route.push(name);
    }
    for (i = 0, len = symbols.length; i < len; i++) {
      symbol = symbols[i];
      entry = registry[symbol];
      if (entry.length === 0) {
        route.push(symbol);
        if (!/(?:\/\/)|(?:\/$)/.test((path = route.join('/')))) {
          paths.add(path);
        }
        route.pop();
      } else {
        _condense(registry, seen, paths, symbol, route);
      }
    }
    if (is_public_name) {
      route.pop();
    }
    return null;
  };

  operators_from_paths = function(paths) {
    var R, _, i, len, literal, match, path, type;
    R = {};
    for (i = 0, len = paths.length; i < len; i++) {
      path = paths[i];

      /* TAINT pattern should allow literal double quotes */
      if (!(match = path.match(/\+([^\/+]+)\+.*"([^"])"$/))) {
        throw new Error("illegal path " + (rpr(path)));
      }
      _ = match[0], type = match[1], literal = match[2];
      R[literal] = type;
    }
    return R;
  };

  if (module.parent == null) {
    paths = condense(IDLX_GRAMMAR);
    info(paths);
    help(operators_from_paths(paths));
    process.exit(1);
  }

}).call(this);

//# sourceMappingURL=main.js.map
