{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n############################################################################################################\nPATH                      = require 'path'\n#...........................................................................................................\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'NEARlEY'\nlog                       = CND.get_logger 'plain',     badge\ndebug                     = CND.get_logger 'debug',     badge\ninfo                      = CND.get_logger 'info',      badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\nNEARLEY                   = require 'nearley'\nIDL_GRAMMAR               = require './idl'\nIDLX_GRAMMAR              = require './idlx'\nlast_of                   = ( x ) -> x[ x.length - 1 ]\n{ isa\n  type_of\n  validate\n  equals   }              = require './types'\n\n\n#===========================================================================================================\n# COMPATIBILITY WITH MKNCR\n#-----------------------------------------------------------------------------------------------------------\n@_NCR = NCR = Object.create require 'ncr-norangereader'\nNCR._input_default = 'xncr'\nNCR.jzr_as_uchr = ( glyph ) ->\n  # return @as_uchr glyph, input: 'xncr' if ( @as_csg glyph, input: 'xncr' ) is 'jzr'\n  return @as_uchr glyph if ( @as_csg glyph ) is 'jzr'\n  return glyph\n\n#-----------------------------------------------------------------------------------------------------------\nNCR.jzr_as_xncr = ( glyph ) ->\n  # nfo = @analyze glyph, input: 'xncr'\n  nfo = @analyze glyph\n  return glyph unless ( nfo.rsg is 'u-pua' ) or ( nfo.csg is 'jzr' )\n  return @as_chr nfo.cid, { csg: 'jzr', }\n\n\n#===========================================================================================================\n# LEXER\n#-----------------------------------------------------------------------------------------------------------\nIdl_lexer = ->\n  @reset ''\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\nIdl_lexer::reset = ( data, state ) ->\n  @buffer = NCR.chrs_from_text data, input: 'xncr'\n  @index  = 0\n  @line   = if state then state.line else 1\n  @prv_nl = if state then -state.col else 0\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\nIdl_lexer::next = ->\n  if @index < @buffer.length\n    chr     = NCR.jzr_as_uchr @buffer[ @index ]\n    @index += +1\n    if chr is '\\n'\n      @line  += +1\n      @prv_nl = @index\n    # return { value: chr, line: @line, col: @index - @prv_nl, }\n    return { value: chr, }\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\nIdl_lexer::save = ->\n  return { line: @line, col: @index - @prv_nl, }\n\n#-----------------------------------------------------------------------------------------------------------\nIdl_lexer::formatError = ( token, message ) ->\n  R = \"#{message} at index #{@index - 1} (#{@buffer.join ''})\"\n  return R\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@IDL = {}\n\n#-----------------------------------------------------------------------------------------------------------\n@IDL.parse = ( source ) ->\n  throw new Error \"expected a text, got a #{type}\" unless ( type = type_of source ) is 'text'\n  throw new Error \"expected a non-empty text, got an empty text\" if source.length is 0\n  ### TAINT should we rewind()? finish()? parser? ###\n  @_parser = new NEARLEY.Parser IDL_GRAMMAR.ParserRules, IDL_GRAMMAR.ParserStart, { lexer: new Idl_lexer(), }\n  # @_parser.reset()\n  @_parser.feed source\n  throw new Error \"Syntax Error: #{rpr source}\" unless @_parser.results.length is 1\n  R = @_parser.results[ 0 ]\n  R = R[ 0 ] if R.length is 1\n  return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @IDLX = # Object.assign Object.create @IDL\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX = {}\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX.parse = ( source ) ->\n  throw new Error \"expected a text, got a #{type}\" unless ( type = type_of source ) is 'text'\n  throw new Error \"expected a non-empty text, got an empty text\" if source.length is 0\n  ### TAINT should we rewind()? finish()? parser? ###\n  @_parser = new NEARLEY.Parser IDLX_GRAMMAR.ParserRules, IDLX_GRAMMAR.ParserStart, { lexer: new Idl_lexer(), }\n  # @_parser.reset()\n  @_parser.feed source\n  throw new Error \"Syntax Error: #{rpr source}\" unless @_parser.results.length is 1\n  R = @_parser.results[ 0 ]\n  # debug '33398', ( rpr R ), R.length\n  R = R[ 0 ] if R.length is 1\n  return R\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n### TAINT methods in this section should be made available for IDL as well ###\n\n# #-----------------------------------------------------------------------------------------------------------\n# @IDLX.get_literals_and_types = => @_get_literals_and_types IDLX_GRAMMAR\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX._get_literals_and_types = ( grammar ) =>\n  paths = @IDLX._paths_from_grammar grammar\n  return @IDLX._literals_and_types_from_paths paths\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX._literals_and_types_from_paths = ( paths ) =>\n  R = {}\n  for path in paths\n    ### TAINT pattern should allow literal double quotes ###\n    unless ( match = path.match /// \\+ ( [^ \\/ + ]+ ) \\+ .* \" ( [^ \"] ) \"  $ /// )\n      throw new Error \"illegal path #{rpr path}\"\n    [ _\n      type\n      literal ]   = match\n    R[ literal ]  = type\n    # ( R[ type ] ?= [] ).push literal\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX._paths_from_grammar = ( grammar ) =>\n  registry  = @IDLX._registry_from_grammar grammar\n  paths     = new Set()\n  @IDLX._condense registry, ( new Set() ), paths, grammar.ParserStart\n  return Array.from paths\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX._registry_from_grammar = ( grammar ) =>\n  R = {}\n  for rule in grammar.ParserRules\n    { name, symbols, } = rule\n    for symbol in symbols\n      if isa.object symbol\n        symbol = '\"' + symbol.literal + '\"'\n      entry   = R[ symbol ] ?= []\n      target  = R[ name   ] ?= []\n      target.push symbol\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX._condense = ( registry, seen, paths, name, route = [] ) =>\n  return if seen.has name\n  seen. add name\n  symbols         = registry[ name ]\n  is_public_name  = not /\\$/.test name\n  route.push name if is_public_name\n  for symbol in symbols\n    entry = registry[ symbol ]\n    if ( entry.length is 0 )\n      route.push symbol\n      paths.add path unless /// (?: \\/\\/ ) | (?: \\/ $ ) ///.test ( path = route.join '/' )\n      route.pop()\n    else\n      @IDLX._condense registry, seen, paths, symbol, route\n  route.pop() if is_public_name\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX.type_from_literal = ( literal ) => @IDLX.literals_and_types[ literal ] ? 'component'\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX.list_tokens = ( diagram_or_formula, settings ) =>\n  switch type = type_of diagram_or_formula\n    when 'text' then diagram = @IDLX.parse  diagram_or_formula\n    when 'list' then diagram =              diagram_or_formula\n    else throw new Error \"expected a text or a list, got a #{type} in #{rpr diagram_or_formula}\"\n  R         = []\n  R.i_base  = -1\n  R         = @IDLX._list_tokens diagram, R, settings ? {}\n  delete R.i_base\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX._list_tokens = ( diagram, R, settings ) =>\n  ### `settings.all_brackets` is needed by `ngrams.get_relational_bigrams_as_tokens` to get brackets\n  around all operators. Brackets that are added for binary operators with two arguments and unary\n  operators are here called 'epenthetical'; they get no index (`token.i`) and the indices on the\n  other tokens are the same as the ones for a formula without epenthetical brackets. ###\n  if settings.all_brackets ? no\n    is_bracketed    = yes\n    is_epenthetical = ( diagram.length <= 3 )\n  #.........................................................................................................\n  else\n    is_bracketed    = ( diagram.length > 3 )\n    is_epenthetical = no\n  #.........................................................................................................\n  if is_bracketed\n    if is_epenthetical\n      R.push { t: 'lbracket', s: '(', i: null, }\n    else\n      R.i_base += +1\n      R.push { t: 'lbracket', s: '(', i: R.i_base, }\n  #.........................................................................................................\n  is_first = yes\n  for element in diagram\n    switch type = type_of element\n      when 'text'\n        token_type  = @IDLX.type_from_literal element\n        # i           = if is_epenthetical\n        R.i_base += +1\n        R.push { t: token_type, s: element, i: R.i_base, }\n      when 'list'\n        if is_first\n          throw new Error \"expected a text as first element of diagram, got a #{type} in #{rpr diagram}\"\n        @IDLX._list_tokens element, R, settings\n      else\n        throw new Error \"expected a text or a list, got a #{type} in #{rpr diagram}\"\n    is_first = no\n  #.........................................................................................................\n  if is_bracketed\n    if is_epenthetical\n      R.push { t: 'rbracket', s: ')', i: null, }\n    else\n      R.i_base += +1\n      R.push { t: 'rbracket', s: ')', i: R.i_base, }\n  #.........................................................................................................\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX.get_formula = ( diagram_or_formula ) =>\n  ### TAINT possible inputs should be formula, diagram, or tokenlist ###\n  return ( literal for { s: literal, } in @IDLX.list_tokens diagram_or_formula ).join ''\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX._text_with_jzr_glyphs_as_uchrs = ( text ) =>\n  return ( NCR.jzr_as_uchr glyph for glyph in NCR.chrs_from_text text ).join ''\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX._text_with_jzr_glyphs_as_xncrs = ( text ) =>\n  return ( NCR.jzr_as_xncr glyph for glyph in NCR.chrs_from_text text ).join ''\n\n\n#===========================================================================================================\n# TREE-SHAKING\n#-----------------------------------------------------------------------------------------------------------\n@IDLX.formula_may_be_nonminimal = ( formula ) =>\n  throw new Error \"expected a text, got a #{type}\" unless ( type = type_of formula ) is 'text'\n  return @IDLX._get_treeshaker_litmus().test formula\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX.minimize_diagram = ( diagram ) =>\n  unless ( type = type_of diagram ) is 'list'\n    throw new Error \"expected a list, got a #{type} in #{rpr diagram}\"\n  return @IDLX._shake_tree JSON.parse JSON.stringify diagram\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX.minimize_formula = ( formula ) =>\n  unless ( type = type_of formula ) is 'text'\n    throw new Error \"expected a text, got a #{type} in #{rpr formula}\"\n  return @IDLX.get_formula @IDLX._shake_tree @IDLX.parse formula\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX._shake_tree = ( diagram ) =>\n  unless ( type = type_of diagram ) is 'list'\n    throw new Error \"expected a list, got a #{type}\"\n  #.........................................................................................................\n  operator = diagram[ 0 ]\n  # #.........................................................................................................\n  # unless ( type = operator_token.t ) is 'operator'\n  #   throw new Error \"expected an operator, got a #{type}\"\n  #.........................................................................................................\n  argument_idx = 0\n  #.........................................................................................................\n  loop\n    argument_idx += +1\n    break if argument_idx > diagram.length - 1\n    sub_tree      = diagram[ argument_idx ]\n    continue unless ( type_of sub_tree ) is 'list'\n    sub_operator  = sub_tree[ 0 ]\n    #.......................................................................................................\n    # unless ( type = type_of sub_operator_token ) is 'MOJIKURA-IDL/token'\n    #   throw new Error \"expected a MOJIKURA-IDL/token, got a #{type}\"\n    # #.......................................................................................................\n    # unless ( type = sub_operator_token.t ) is 'operator'\n    #   throw new Error \"expected an operator, got a #{type}\"\n    #.......................................................................................................\n    if operator is sub_operator\n      diagram[ argument_idx .. argument_idx ] = sub_tree[ 1 .. ]\n      argument_idx += -1\n    else\n      @IDLX._shake_tree sub_tree\n  return diagram\n\n#-----------------------------------------------------------------------------------------------------------\n@IDLX._get_treeshaker_litmus = =>\n  ### When `@IDLX._get_treeshaker_litmus.pattern` matches a formula, it *may* be non-minimal; if the pattern\n  does *not* match a formula, there are certainly no opportunities for optimization. The pattern works by\n  trying to match sequences like `/...|(?:O[^MNPQ]*O)|(?:P[^MNOQ]*P)|.../`, where `MNOPQ` are the binary\n  operators. ###\n  return R if ( R = @IDLX._get_treeshaker_litmus.pattern )?\n  #.........................................................................................................\n  binary_operators = []\n  for symbol, token_type of @IDLX.literals_and_types\n    binary_operators.push symbol if token_type is 'binary_operator'\n  # binary_operators = binary_operators[ .. 3 ]\n  # debug '52998', binary_operators\n  pattern = []\n  for operator in binary_operators\n    sub_pattern = []\n    sub_pattern.push '[^'\n    for sub_operator in binary_operators\n      continue if sub_operator is operator\n      sub_pattern.push sub_operator\n    sub_pattern.push ']*'\n    pattern.push '(?:' + operator + ( sub_pattern.join '' ) + operator + ')'\n  #.........................................................................................................\n  return @IDLX._get_treeshaker_litmus.pattern = new RegExp pattern.join '|'\n\n############################################################################################################\n@IDLX._get_treeshaker_litmus.pattern  = null\n@IDLX.literals_and_types              = @IDLX._get_literals_and_types IDLX_GRAMMAR\n\n\n#===========================================================================================================\n# SILHOUTTES, NGRAMS\n#-----------------------------------------------------------------------------------------------------------\n### NOTE: do not use parametric `require()` as this may throw off browserify (and rightly so) ###\nIDLX        = @IDLX\nSILHOUETTES = require './silhouettes'\nNGRAMS      = require './ngrams'\ndo ->\n  for name, value of SILHOUETTES\n    IDLX[ name ] = value\n  for name, value of NGRAMS\n    IDLX[ name ] = value\n  return null\n\n\n############################################################################################################\nunless module.parent?\n    #.........................................................................................................\n    info @IDLX._get_literals_and_types IDLX_GRAMMAR\n    info @IDLX.type_from_literal IDLX_GRAMMAR\n    help '↻', @IDLX.type_from_literal '↻' # 'operator',\n    help '〓', @IDLX.type_from_literal '〓' # 'proxy',\n    help '§', @IDLX.type_from_literal '§' # 'proxy',\n    help '⿰', @IDLX.type_from_literal '⿰' # 'operator',\n    help '⿻', @IDLX.type_from_literal '⿻' # 'operator',\n    help '◰', @IDLX.type_from_literal '◰' # 'operator',\n    help '(', @IDLX.type_from_literal '(' # 'bracket',\n    help 'x', @IDLX.type_from_literal 'x' # 'other',\n    formula       = '⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人人丨))'\n    whisper formula\n    help diagram  = @IDLX.parse formula\n    whisper formula\n    help tokens   = @IDLX.list_tokens diagram\n    urge @IDLX.get_formula formula\n    urge @IDLX.get_formula diagram\n    urge @IDLX._get_treeshaker_litmus()\n    urge ( CND.yellow formula    ), ( CND.blue CND.truth @IDLX.formula_may_be_nonminimal formula    )\n    urge ( CND.yellow '⿱⿱𫝀口㐄'    ), ( CND.blue CND.truth @IDLX.formula_may_be_nonminimal '⿱⿱𫝀口㐄'    )\n    urge ( CND.yellow '⿱𫝀⿱口㐄'    ), ( CND.blue CND.truth @IDLX.formula_may_be_nonminimal '⿱𫝀⿱口㐄'    )\n    urge ( CND.yellow '⿰韋(⿱白大十)' ), ( CND.blue CND.truth @IDLX.formula_may_be_nonminimal '⿰韋(⿱白大十)' )\n    info ( CND.yellow formula    ), ( CND.blue @IDLX.minimize_formula formula                       )\n    info ( CND.yellow '⿱⿱𫝀口㐄'    ), ( CND.blue @IDLX.minimize_formula '⿱⿱𫝀口㐄'                       )\n    info ( CND.yellow '⿱𫝀⿱口㐄'    ), ( CND.blue @IDLX.minimize_formula '⿱𫝀⿱口㐄'                       )\n    info ( CND.yellow '⿰韋(⿱白大十)' ), ( CND.blue @IDLX.minimize_formula '⿰韋(⿱白大十)'                    )\n    process.exit 1\n\n"
  ]
}