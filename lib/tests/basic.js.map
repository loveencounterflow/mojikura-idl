{
  "version": 3,
  "file": "basic.js",
  "sourceRoot": "../..",
  "sources": [
    "src/tests/basic.coffee"
  ],
  "names": [],
  "mappings": ";AAAA;EAAA;AAAA,MAAA;;EAKA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,GAAA,GAA4B,GAAG,CAAC;;EAChC,KAAA,GAA4B;;EAC5B,GAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,OAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,SAAf,EAA4B,KAA5B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,IAAI,CAAC,IAAT,CAAc,GAAd,EAhB5B;;;EAkBA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,CAAA,CAAE,GAAF,EAAO,IAAP,CAAA,GAA4B,OAAA,CAAQ,OAAR,CAA5B,EAnBA;;;;;EAyBA,aAAA,GAAgB,QAAA,CAAE,IAAF,CAAA;AAOd,QAAA,CAAA;;;;;;;IAAA,CAAA,GAAI;IACJ,CAAA,GAAI,CAAC,CAAC,OAAF,CAAU,uBAAV,EAAmC,QAAA,CAAE,EAAF,CAAA;AACrC,UAAA;MAAA,OAAA,GAAU,CAAE,EAAE,CAAC,WAAH,CAAe,CAAf,CAAF,CAAoB,CAAC,QAArB,CAA8B,EAA9B;MACV,IAA2B,OAAO,CAAC,MAAR,KAAkB,CAA7C;QAAA,OAAA,GAAU,GAAA,GAAM,QAAhB;;AACA,aAAO,CAAA,GAAA,CAAA,CAAM,OAAN,CAAA;IAH8B,CAAnC;IAIJ,CAAA,GAAI,CAAC,CAAC,OAAF,CAAU,IAAV,EAAgB,KAAhB;IACJ,CAAA,GAAI,CAAC,CAAC,OAAF,CAAU,MAAV,EAAkB,KAAlB;IACJ,CAAA,GAAI,OAAA,GAAU,CAAV,GAAc;AAClB,WAAO;EAfO,EAzBhB;;;EA2CA,WAAA,GAAc,QAAA,CAAE,CAAF,EAAK,MAAL,CAAA;AACZ,QAAA;AAAA;MACE,CAAA,GAAI,MAAA,CAAA,EADN;KAAA,cAAA;MAEM;AACJ,aAAO,MAAA,CAAO,gBAAA,GAAmB,KAAO,CAAA,SAAA,CAAjC,EAHT;;AAIA,WAAO;EALK,EA3Cd;;;;;EAsDA,GAAG,CAAC,IAAJ,CAAS,OAAT,EAAkB,QAAA,CAAE,CAAF,CAAA;WAAS,CAAC,CAAC,GAAF,CAAA;EAAT,CAAlB;;EAtDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA",
  "sourcesContent": [
    "\n\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'MOJIKURA-IDL/tests'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\nTAP                       = require 'tap'\n{ IDL, IDLX, }            = require '../..'\n\n\n#===========================================================================================================\n# HELPERS\n#-----------------------------------------------------------------------------------------------------------\nnice_text_rpr = ( text ) ->\n  ### Ad-hoc method to print out text in a readable, CoffeeScript-compatible, triple-quoted way. Line breaks\n  (`\\\\n`) will be shown as line breaks, so texts should not be as spaghettified as they appear with\n  JSON.stringify (the last line break of a string is, however, always shown in its symbolic form so it\n  won't get swallowed by the CoffeeScript parser). Code points below U+0020 (space) are shown as\n  `\\\\x00`-style escapes, taken up less space than `\\u0000` escapes while keeping things explicit. All\n  double quotes will be prepended with a backslash. ###\n  R = text\n  R = R.replace /[\\x00-\\x09\\x0b-\\x19]/g, ( $0 ) ->\n    cid_hex = ( $0.codePointAt 0 ).toString 16\n    cid_hex = '0' + cid_hex if cid_hex.length is 1\n    return \"\\\\x#{cid_hex}\"\n  R = R.replace /\"/g, '\\\\\"'\n  R = R.replace /\\n$/g, '\\\\n'\n  R = '\\n\"\"\"' + R + '\"\"\"'\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\nresume_next = ( T, method ) ->\n  try\n    R = method()\n  catch error\n    return Symbol \"### ERROR ### \" + error[ 'message' ]\n  return R\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\nTAP.test \"dummy\", ( T ) -> T.end()\n\n\n# #===========================================================================================================\n# # TESTS (SANITY CHECKS)\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"sanity checks (grammar data)\" ] = ( T ) ->\n#   T.ok '⿰' of IDL._parser_settings.operators\n#   T.ok '⿱' of IDL._parser_settings.operators\n#   T.ok '⿴' of IDL._parser_settings.operators\n#   T.ok '⿵' of IDL._parser_settings.operators\n#   T.ok '⿶' of IDL._parser_settings.operators\n#   T.ok '⿷' of IDL._parser_settings.operators\n#   T.ok '⿸' of IDL._parser_settings.operators\n#   T.ok '⿹' of IDL._parser_settings.operators\n#   T.ok '⿺' of IDL._parser_settings.operators\n#   T.ok '⿻' of IDL._parser_settings.operators\n#   T.ok '⿲' of IDL._parser_settings.operators\n#   T.ok '⿳' of IDL._parser_settings.operators\n#   #.........................................................................................................\n#   T.ok '⿰' of IDLX._parser_settings.operators\n#   T.ok '⿱' of IDLX._parser_settings.operators\n#   T.ok '⿴' of IDLX._parser_settings.operators\n#   T.ok '⿵' of IDLX._parser_settings.operators\n#   T.ok '⿶' of IDLX._parser_settings.operators\n#   T.ok '⿷' of IDLX._parser_settings.operators\n#   T.ok '⿸' of IDLX._parser_settings.operators\n#   T.ok '⿹' of IDLX._parser_settings.operators\n#   T.ok '⿺' of IDLX._parser_settings.operators\n#   T.ok '⿻' of IDLX._parser_settings.operators\n#   T.ok '⿲' not of IDLX._parser_settings.operators\n#   T.ok '⿳' not of IDLX._parser_settings.operators\n#   T.ok '◰' of IDLX._parser_settings.operators\n#   T.ok '≈' of IDLX._parser_settings.operators\n#   T.ok '↻' of IDLX._parser_settings.operators\n#   T.ok '↔' of IDLX._parser_settings.operators\n#   T.ok '↕' of IDLX._parser_settings.operators\n#   T.ok '●' of IDLX._parser_settings.solitaires\n#   #.........................................................................................................\n#   T.ok IDL._parser_settings           isnt IDLX._parser_settings\n#   T.ok IDL._parser_settings.operators isnt IDLX._parser_settings.operators\n#   T.ok not CND.equals IDL._parser_settings,            IDLX._parser_settings\n#   T.ok not CND.equals IDL._parser_settings.operators,  IDLX._parser_settings.operators\n#   #.........................................................................................................\n#   return null\n\n\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDL) parse tree of simple formulas\" ] = ( T ) ->\n#   probes_and_matchers = [\n#     [\"⿲木木木\",[{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"⿲\",\"idx\":0,\"t\":\"operator\",\"a\":3,\"n\":\"pillars\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"木\",\"idx\":1,\"t\":\"component\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"木\",\"idx\":2,\"t\":\"component\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"木\",\"idx\":3,\"t\":\"component\"}]]\n#     [\"⿱癶⿰弓貝\",[{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"⿱\",\"idx\":0,\"t\":\"operator\",\"a\":2,\"n\":\"top/down\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"癶\",\"idx\":1,\"t\":\"component\"},[{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"⿰\",\"idx\":2,\"t\":\"operator\",\"a\":2,\"n\":\"left-right\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"弓\",\"idx\":3,\"t\":\"component\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"貝\",\"idx\":4,\"t\":\"component\"}]]]\n#     [\"⿱⿰亻式貝\",[{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"⿱\",\"idx\":0,\"t\":\"operator\",\"a\":2,\"n\":\"top/down\"},[{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"⿰\",\"idx\":1,\"t\":\"operator\",\"a\":2,\"n\":\"left-right\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"亻\",\"idx\":2,\"t\":\"component\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"式\",\"idx\":3,\"t\":\"component\"}],{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"貝\",\"idx\":4,\"t\":\"component\"}]]\n#     [\"⿱⿰亻式⿱目八\",[{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"⿱\",\"idx\":0,\"t\":\"operator\",\"a\":2,\"n\":\"top/down\"},[{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"⿰\",\"idx\":1,\"t\":\"operator\",\"a\":2,\"n\":\"left-right\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"亻\",\"idx\":2,\"t\":\"component\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"式\",\"idx\":3,\"t\":\"component\"}],[{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"⿱\",\"idx\":4,\"t\":\"operator\",\"a\":2,\"n\":\"top/down\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"目\",\"idx\":5,\"t\":\"component\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"八\",\"idx\":6,\"t\":\"component\"}]]]\n#     [\"⿺辶言\",[{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"⿺\",\"idx\":0,\"t\":\"operator\",\"a\":2,\"n\":\"leftbottom\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"辶\",\"idx\":1,\"t\":\"component\"},{\"~isa\":\"MOJIKURA-IDL/token\",\"s\":\"言\",\"idx\":2,\"t\":\"component\"}]]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = resume_next T, -> IDL.tokentree_from_source probe\n#     urge JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   #.........................................................................................................\n#   return null\n\n# #===========================================================================================================\n# # TESTS (IDLX)\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDLX) parse simple formulas\" ] = ( T ) ->\n#   probes_and_matchers = [\n#     [\"⿱癶⿰弓貝\",[\"⿱\",\"癶\",[\"⿰\",\"弓\",\"貝\"]]]\n#     [\"⿱⿰亻式貝\",[\"⿱\",[\"⿰\",\"亻\",\"式\"],\"貝\"]]\n#     [\"⿱⿰亻式⿱目八\",[\"⿱\",[\"⿰\",\"亻\",\"式\"],[\"⿱\",\"目\",\"八\"]]]\n#     [\"⿺辶言\",[\"⿺\",\"辶\",\"言\"]]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = resume_next T, -> IDLX.diagram_from_source probe\n#     urge JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   #.........................................................................................................\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDLX) reject bogus formulas\" ] = ( T ) ->\n#   probes_and_matchers = [\n#     [\"木\",\"IDL: lone token of type 'component' [  ✘ 木 ✘  ]\"]\n#     [42,\"expected a text, got a number\"]\n#     [\"〓\",\"IDL: lone token of type 'proxy' [  ✘ 〓 ✘  ]\"]\n#     [\"\",\"IDL: empty text\"]\n#     [\"⿱⿰亻式⿱目八木木木\",\"IDL: extra token(s) [ ⿱⿰亻式⿱目八 ✘ 木 ✘ 木木 ]\"]\n#     [\"⿺廴聿123\",\"IDL: extra token(s) [ ⿺廴聿 ✘ 1 ✘ 23 ]\"]\n#     [\"⿺\",\"IDLX: premature end of source [  ✘ ⿺ ✘  ]\"]\n#     [\"⿺⿺⿺⿺\",\"IDLX: premature end of source [ ⿺⿺⿺ ✘ ⿺ ✘  ]\"]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     try\n#       result = IDLX.diagram_from_source probe\n#       T.fail \"expected an exception, got result #{rpr result}\"\n#     catch error\n#       message = CND.remove_colors error[ 'message' ]\n#       warn JSON.stringify [ probe, message, ]\n#       T.eq message, matcher\n#   #.........................................................................................................\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDLX) reject IDL operators with arity 3\" ] = ( T ) ->\n#   probes_and_matchers = [\n#     [\"⿲木木木\",\"IDL: extra token(s) [ ⿲ ✘ 木 ✘ 木木 ]\"]\n#     [\"⿳木木木\",\"IDL: extra token(s) [ ⿳ ✘ 木 ✘ 木木 ]\"]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     try\n#       result = IDLX.diagram_from_source probe\n#       T.fail \"expected an exception, got result #{rpr result}\"\n#     catch error\n#       message = CND.remove_colors error[ 'message' ]\n#       warn JSON.stringify [ probe, message, ]\n#       T.eq message, matcher\n#   #.........................................................................................................\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDLX) parse extended formulas (plain)\" ] = ( T ) ->\n#   probes_and_matchers = [\n#       [ '↻正', [ '↻', '正', ], ]\n#       [ '↔≈匕', [ '↔', [ '≈', '匕' ] ], ]\n#       [ '↔正', [ '↔', '正', ], ]\n#       [ '⿱丶乂', [ '⿱', '丶', '乂', ], ]\n#       [ '⿺走⿹◰口戈日', [ '⿺', '走', [ '⿹', [ '◰', '口', '戈' ], '日' ] ], ]\n#       ['≈匚', [ '≈', '匚' ], ]\n#       [\"≈&jzr#xe174;\",[\"≈\",\"\"]]\n#       ['≈非', [ '≈', '非' ], ]\n#       [ '⿺走⿹◰口〓日', [ '⿺', '走', [ '⿹', [ '◰', '口', '〓' ], '日' ] ], ]\n#       [\"⿻串⿰立&jzr#x1234;\",[\"⿻\",\"串\",[\"⿰\",\"立\",\"ሴ\"]]]\n#       [\"⿱丶⿵𠘨§\",[\"⿱\",\"丶\",[\"⿵\",\"𠘨\",\"§\"]]]\n#       # [ '𡦹:⿱丶⿵𠘨§', [ '⿱', '§', '&jzr#xe199;' ], ]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = resume_next T, -> IDLX.diagram_from_source probe\n#     urge JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   #.........................................................................................................\n#   return null\n\n\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDLX) reject bogus formulas (solitaires)\" ] = ( T ) ->\n#   probes_and_matchers = [\n#     [\"〓\",\"IDL: lone token of type 'proxy' [  ✘ 〓 ✘  ]\"]\n#     [\"§\",\"IDL: lone token of type 'proxy' [  ✘ § ✘  ]\"]\n#     [\"⿱式●\",\"IDLX: cannot have a solitaire here [ ⿱式 ✘ ● ✘  ]\"]\n#     [\"⿱式▽\",\"IDLX: cannot have a solitaire here [ ⿱式 ✘ ▽ ✘  ]\"]\n#     [\"⿱式∅\",\"IDLX: cannot have a solitaire here [ ⿱式 ✘ ∅ ✘  ]\"]\n#     [\"⿱〓▽\",\"IDLX: cannot have a solitaire here [ ⿱〓 ✘ ▽ ✘  ]\"]\n#     [\"↻●\",\"IDLX: cannot have a solitaire here [ ↻ ✘ ● ✘  ]\"]\n#     [\"↔≈▽\",\"IDLX: cannot have a solitaire here [ ↔≈ ✘ ▽ ✘  ]\"]\n#     [\"●亻\",\"IDLX: cannot have a solitaire here [  ✘ ● ✘ 亻 ]\"]\n#     [\"(●亻式)\",\"IDLX: cannot have a solitaire here [ ( ✘ ● ✘ 亻式) ]\"]\n#     [\"(⿰亻●式)\",\"IDLX: cannot have a solitaire here [ (⿰亻 ✘ ● ✘ 式) ]\"]\n#     [\"(⿱▽㓁允)\",\"IDLX: cannot have a solitaire here [ (⿱ ✘ ▽ ✘ 㓁允) ]\"]\n#     [\"⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人●丨))\",\"IDLX: cannot have a solitaire here [ ⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人 ✘ ● ✘ 丨)) ]\"]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     try\n#       result = IDLX.diagram_from_source probe\n#       T.fail \"expected an exception, got result #{rpr result}\"\n#     catch error\n#       message = CND.remove_colors error[ 'message' ]\n#       warn JSON.stringify [ probe, message, ]\n#       T.eq message, matcher\n#   #.........................................................................................................\n#   return null\n\n\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDLX) _tokentree_as_formula\" ] = ( T ) ->\n#   ### TAINT configurables:\n#   * whether to render JZR codepoints as PUA codepoints or as XNCRs\n#   * whether to fix systematic IDL blunders such as ⿺辶言\n#   * other normalizations (e.g. order of operators / terms)?\n#   ###\n#   probes_and_matchers = [\n#     [\"⿺辶言\",\"⿺辶言\"]\n#     [\"⿺辶〓\",\"⿺辶〓\"]\n#     [\"●\",\"●\"]\n#     [\"∅\",\"∅\"]\n#     [\"▽\",\"▽\"]\n#     [\"⿱癶⿰弓貝\",\"⿱癶⿰弓貝\"]\n#     [\"⿱⿰亻式貝\",\"⿱⿰亻式貝\"]\n#     [\"⿱⿰亻式⿱目八\",\"⿱⿰亻式⿱目八\"]\n#     [\"≈〇\",\"≈〇\"]\n#     [\"⿱〓〓\",\"⿱〓〓\"]\n#     [\"↻正\",\"↻正\"]\n#     [\"↔≈匕\",\"↔≈匕\"]\n#     [\"↔正\",\"↔正\"]\n#     [\"⿱丶乂\",\"⿱丶乂\"]\n#     [\"⿺走⿹◰口戈日\",\"⿺走⿹◰口戈日\"]\n#     [\"≈匚\",\"≈匚\"]\n#     [\"(⿱北㓁允)\",\"(⿱北㓁允)\"]\n#     [\"⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人人丨))\",\"⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人人丨))\"]\n#     [\"⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人人丨))\",\"⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人人丨))\"]\n#     [\"⿰臣(⿱𠂉(⿰人人人)(⿰古古古))\",\"⿰臣(⿱𠂉(⿰人人人)(⿰古古古))\"]\n#     [\"≈&jzr#xe174;\",\"≈&jzr#xe174;\"]\n#     [\"(⿱&jzr#xe223;一八⿰(⿱&jzr#xe223;一八)(⿱&jzr#xe223;一八))\",\"(⿱&jzr#xe223;一八⿰(⿱&jzr#xe223;一八)(⿱&jzr#xe223;一八))\"]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     ctx     = IDLX.parse probe\n#     # help JSON.stringify IDLX._get_diagram ctx\n#     result  = IDLX._tokentree_as_formula ctx, ctx.tokentree, 'xncr'\n#     urge JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   #.........................................................................................................\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDLX) formula_from_source (1)\" ] = ( T ) ->\n#   probes_and_matchers = [\n#     [\"(⿱亠口冖一口十)\",\"(⿱亠口冖一口十)\"]\n#     [\"(⿱𠚤冖丿&cdp#x88c6;一八)\",\"(⿱𠚤冖丿&cdp#x88c6;一八)\"]\n#     [\"(⿱卄亠口冖口毛)\",\"(⿱卄亠口冖口毛)\"]\n#     [\"⿱卄⿰木貝\",\"⿱卄⿰木貝\"]\n#     [\"⿱艸⿰白⿹&jzr#xe19f;灬\",\"⿱艸⿰白⿹&jzr#xe19f;灬\"]\n#     ]\n#   #.........................................................................................................\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = IDLX.formula_from_source probe, 'xncr'\n#     urge JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   #.........................................................................................................\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDLX) formula_from_source (2)\" ] = ( T ) ->\n#   probes_and_matchers = [\n#     [\"(⿱亠口冖一口十)\",\"(⿱亠口冖一口十)\"]\n#     [\"(⿱𠚤冖丿&cdp#x88c6;一八)\",\"(⿱𠚤冖丿&cdp#x88c6;一八)\"]\n#     [\"(⿱卄亠口冖口毛)\",\"(⿱卄亠口冖口毛)\"]\n#     [\"⿱卄⿰木貝\",\"⿱卄⿰木貝\"]\n#     [\"⿱艸⿰白⿹&jzr#xe19f;灬\",\"⿱艸⿰白⿹灬\"]\n#     ]\n#   #.........................................................................................................\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = IDLX.formula_from_source probe, 'uchr'\n#     urge JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   #.........................................................................................................\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDLX) sexpr_from_source\" ] = ( T ) ->\n#   probes_and_matchers = [\n#     [\"●\",\"( ● )\"]\n#     [\"∅\",\"( ∅ )\"]\n#     [\"▽\",\"( ▽ )\"]\n#     [\"⿺辶言\",\"( ⿺ 辶 言 )\"]\n#     [\"⿺辶〓\",\"( ⿺ 辶 〓 )\"]\n#     [\"⿱癶⿰弓貝\",\"( ⿱ 癶 ( ⿰ 弓 貝 ) )\"]\n#     [\"⿱⿰亻式貝\",\"( ⿱ ( ⿰ 亻 式 ) 貝 )\"]\n#     [\"⿱⿰亻式⿱目八\",\"( ⿱ ( ⿰ 亻 式 ) ( ⿱ 目 八 ) )\"]\n#     [\"≈〇\",\"( ≈ 〇 )\"]\n#     [\"⿱〓〓\",\"( ⿱ 〓 〓 )\"]\n#     [\"↻正\",\"( ↻ 正 )\"]\n#     [\"(⿱亠口冖一口十)\",\"( ⿱ 亠 口 冖 一 口 十 )\"]\n#     [\"(⿱𠚤冖丿&cdp#x88c6;一八)\",\"( ⿱ 𠚤 冖 丿 &cdp#x88c6; 一 八 )\"]\n#     [\"(⿱卄亠口冖口毛)\",\"( ⿱ 卄 亠 口 冖 口 毛 )\"]\n#     [\"⿱卄⿰木貝\",\"( ⿱ 卄 ( ⿰ 木 貝 ) )\"]\n#     [\"⿱艸⿰白⿹&jzr#xe19f;灬\",\"( ⿱ 艸 ( ⿰ 白 ( ⿹ &jzr#xe19f; 灬 ) ) )\"]\n#     ]\n#   #.........................................................................................................\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = IDLX.sexpr_from_source probe, 'xncr'\n#     # urge JSON.stringify [ probe, result, ]\n#     urge ( CND.grey probe ), ( CND.lime result )\n#     T.eq result, matcher\n#   #.........................................................................................................\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(experimental) using arbitrary characters as components\" ] = ( T ) ->\n#   probes_and_matchers = [\n#     # [ '⿰ᄀᄀ',        '( ⿰ ᄀ ᄀ )', ]                # ᄁ\n#     # [ '⿰（三）',     '( ⿰ （ 三 ） )', ]      # ㈢\n#     # [ '⿱⿰株式⿰会社',    '⿱ ⿰ 株 式 ⿰ 会 社', ]      # ㍿\n#     # [\"⿱´a\",\"\"]\n#     # [\"⿺Lx\",\"\"]\n#     [ '⿰\\\\(三\\\\) )',   '( ⿰ \\\\( 三 \\\\) )', ]      # ㈢\n#     [ '⿴〇上',        '( ⿴ 〇 上 )', ]          # ㊤\n#     # [ '☱', '(⿱xxx)', ]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     try\n#       result = IDLX.sexpr_from_source probe, 'xncr'\n#     catch error\n#       T.fail error.message\n#       continue\n#     urge JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   #.........................................................................................................\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDLX) doubt mark\" ] = ( T ) ->\n#   probes_and_matchers = [\n#     [\"⿰魚?𦟝\",\"( ⿰ 魚 ( ? 𦟝 ) )\"] # 𩼿\n#     ]\n#   #.........................................................................................................\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = IDLX.sexpr_from_source probe, 'xncr'\n#     # urge JSON.stringify [ probe, result, ]\n#     urge ( CND.grey probe ), ( CND.lime result )\n#     T.eq result, matcher\n#   #.........................................................................................................\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"(IDLX) tree-shaking\" ] = ( T ) ->\n#   #.........................................................................................................\n#   glyphs_probes_and_matchers = [\n#     [\"㒚\",\"⿰亻⿱(⿱爫工彐)心\",{\"formula_uchr\":\"⿰亻(⿱爫工彐心)\",\"sexpr_uchr\":\"( ⿰ 亻 ( ⿱ 爫 工 彐 心 ) )\",\"diagram\":[\"⿰\",\"亻\",[\"⿱\",\"爫\",\"工\",\"彐\",\"心\"]]}]\n#     [\"㒚\",\"⿰亻(⿱爫工彐心)\",{\"formula_uchr\":\"⿰亻(⿱爫工彐心)\",\"sexpr_uchr\":\"( ⿰ 亻 ( ⿱ 爫 工 彐 心 ) )\",\"diagram\":[\"⿰\",\"亻\",[\"⿱\",\"爫\",\"工\",\"彐\",\"心\"]]}]\n#     [\"㒚\",\"⿰亻⿱爫⿱工⿱彐心\",{\"formula_uchr\":\"⿰亻(⿱爫工彐心)\",\"sexpr_uchr\":\"( ⿰ 亻 ( ⿱ 爫 工 彐 心 ) )\",\"diagram\":[\"⿰\",\"亻\",[\"⿱\",\"爫\",\"工\",\"彐\",\"心\"]]}]\n#     [\"㒚\",\"⿰亻⿱⿱爫⿱工彐心\",{\"formula_uchr\":\"⿰亻(⿱爫工彐心)\",\"sexpr_uchr\":\"( ⿰ 亻 ( ⿱ 爫 工 彐 心 ) )\",\"diagram\":[\"⿰\",\"亻\",[\"⿱\",\"爫\",\"工\",\"彐\",\"心\"]]}]\n#     [\"㒚\",\"⿰亻⿱⿱⿱爫工彐心\",{\"formula_uchr\":\"⿰亻(⿱爫工彐心)\",\"sexpr_uchr\":\"( ⿰ 亻 ( ⿱ 爫 工 彐 心 ) )\",\"diagram\":[\"⿰\",\"亻\",[\"⿱\",\"爫\",\"工\",\"彐\",\"心\"]]}]\n#     [\"㒢\",\"⿰亻(⿱亼⿰⿰口口口𠕁)\",{\"formula_uchr\":\"⿰亻(⿱亼(⿰口口口)𠕁)\",\"sexpr_uchr\":\"( ⿰ 亻 ( ⿱ 亼 ( ⿰ 口 口 口 ) 𠕁 ) )\",\"diagram\":[\"⿰\",\"亻\",[\"⿱\",\"亼\",[\"⿰\",\"口\",\"口\",\"口\"],\"𠕁\"]]}]\n#     [\"㒦\",\"⿰亻⿱⿱田⿰田田土\",{\"formula_uchr\":\"⿰亻(⿱田⿰田田土)\",\"sexpr_uchr\":\"( ⿰ 亻 ( ⿱ 田 ( ⿰ 田 田 ) 土 ) )\",\"diagram\":[\"⿰\",\"亻\",[\"⿱\",\"田\",[\"⿰\",\"田\",\"田\"],\"土\"]]}]\n#     [\"㒦\",\"⿰亻(⿱田⿰田田土)\",{\"formula_uchr\":\"⿰亻(⿱田⿰田田土)\",\"sexpr_uchr\":\"( ⿰ 亻 ( ⿱ 田 ( ⿰ 田 田 ) 土 ) )\",\"diagram\":[\"⿰\",\"亻\",[\"⿱\",\"田\",[\"⿰\",\"田\",\"田\"],\"土\"]]}]\n#     [\"㒪\",\"(⿱人⿰臣臣⿰止豕)\",{\"formula_uchr\":\"(⿱人⿰臣臣⿰止豕)\",\"sexpr_uchr\":\"( ⿱ 人 ( ⿰ 臣 臣 ) ( ⿰ 止 豕 ) )\",\"diagram\":[\"⿱\",\"人\",[\"⿰\",\"臣\",\"臣\"],[\"⿰\",\"止\",\"豕\"]]}]\n#     [\"𠋕\",\"⿰亻⿱⿰工几木\",{\"formula_uchr\":\"⿰亻⿱⿰工几木\",\"sexpr_uchr\":\"( ⿰ 亻 ( ⿱ ( ⿰ 工 几 ) 木 ) )\",\"diagram\":[\"⿰\",\"亻\",[\"⿱\",[\"⿰\",\"工\",\"几\"],\"木\"]]}]\n#     [\"𠋕\",\"⿰<木<几\",{\"formula_uchr\":\"⿰<木<几\",\"sexpr_uchr\":\"( ⿰ ( < 木 ) ( < 几 ) )\",\"diagram\":[\"⿰\",[\"<\",\"木\"],[\"<\",\"几\"]]}]\n#     [\"㐒\",\"⿱⿱刀口乙\",{\"formula_uchr\":\"(⿱刀口乙)\",\"sexpr_uchr\":\"( ⿱ 刀 口 乙 )\",\"diagram\":[\"⿱\",\"刀\",\"口\",\"乙\"]}]\n#     [\"㐥\",\"⿱⿰金⿰且力乙\",{\"formula_uchr\":\"⿱(⿰金且力)乙\",\"sexpr_uchr\":\"( ⿱ ( ⿰ 金 且 力 ) 乙 )\",\"diagram\":[\"⿱\",[\"⿰\",\"金\",\"且\",\"力\"],\"乙\"]}]\n#     [\"㐯\",\"(⿱亠⿱口口⿱禾日)\",{\"formula_uchr\":\"(⿱亠口口禾日)\",\"sexpr_uchr\":\"( ⿱ 亠 口 口 禾 日 )\",\"diagram\":[\"⿱\",\"亠\",\"口\",\"口\",\"禾\",\"日\"]}]\n#     ]\n#   #.........................................................................................................\n#   for [ glyph, probe, matcher, ] in glyphs_probes_and_matchers\n#     old_ctx       = IDLX.parse probe\n#     old_ctx_copy  = JSON.parse JSON.stringify old_ctx\n#     # # debug '30303', old_ctx.tokentree\n#     new_ctx = IDLX.shake_tree old_ctx\n#     T.eq old_ctx, old_ctx_copy\n#     # # debug '30303', old_ctx.tokentree\n#     # debug '22621', CND.truth CND.equals old_ctx, old_ctx_copy\n#     # debug '22621', CND.truth old_ctx.tokentree is new_ctx.tokentree\n#     # debug '22618', new_ctx.tokenlist\n#     # process.exit 1\n#     IDLX._get_formula new_ctx, 'uchr'\n#     IDLX._get_sexpr   new_ctx, 'uchr'\n#     { formula_uchr, sexpr_uchr, diagram, } = new_ctx\n#     probe_maybe_suboptimal  = IDLX.formula_may_be_suboptimal null, probe\n#     probe_was_suboptimal    = probe isnt formula_uchr\n#     # debug JSON.stringify [ glyph, probe, { formula_uchr, sexpr_uchr, diagram, }, ]\n#     # debug ( CND.truth probe_maybe_suboptimal ), ( CND.truth probe_was_suboptimal )\n#     T.eq matcher, { formula_uchr, sexpr_uchr, diagram, }\n#     if not probe_maybe_suboptimal\n#       if probe_was_suboptimal then  T.fail \"check for tree-shaking failed for #{rpr probe} (got #{formula_uchr})\"\n#       else                          T.ok true\n#     else\n#       T.ok true\n#   #.........................................................................................................\n#   return null\n\n# ############################################################################################################\n# unless module.parent?\n#   # debug '0980', JSON.stringify ( Object.keys @ ), null '  '\n#   include = [\n#     \"(IDL) demo\"\n#     \"sanity checks (grammar data)\"\n#     #.......................................................................................................\n#     \"(IDL) parse simple formulas\"\n#     \"(IDL) reject bogus formulas\"\n#     \"(IDL) parse tree of simple formulas\"\n#     #.......................................................................................................\n#     \"(IDLX) reject bogus formulas\"\n#     \"(IDLX) reject IDL operators with arity 3\"\n#     \"(IDLX) parse simple formulas\"\n#     \"(IDLX) parse extended formulas (plain)\"\n#     \"(IDLX) parse extended formulas (bracketed)\"\n#     \"(IDLX) reject bogus formulas (bracketed)\"\n#     \"(IDLX) reject bogus formulas (solitaires)\"\n#     #.......................................................................................................\n#     \"(IDL) _tokentree_as_formula\"\n#     \"(IDLX) _tokentree_as_formula\"\n#     \"(IDLX) formula_from_source (1)\"\n#     \"(IDLX) formula_from_source (2)\"\n#     \"(IDLX) sexpr_from_source\"\n#     #.......................................................................................................\n#     \"(IDLX) doubt mark\"\n#     # \"(experimental) using arbitrary characters as components\"\n#     \"(IDLX) tree-shaking\"\n#     ]\n#   @_prune()\n#   @_main()\n\n\n#   # demo_errors = ->\n#   #   sources = [\n#   #     \"\"\n#   #     \"⿺\"\n#   #     \"走\"\n#   #     \"走⿹◰口弓戈〓\"\n#   #     \"⿺走x\"\n#   #     \"⿺走⿹◰口弓戈〓\"\n#   #     ]\n#   #   for source in sources\n#   #     try\n#   #       d = IDLX.tokentree_from_source source\n#   #     catch error\n#   #       info error[ 'message' ]\n\n#   demo_new_api = ->\n#     debug ( IDLX.diagram_from_source '⿺走日' )\n#     debug ( IDLX.diagram_from_source '(⿱山人儿)' ) # ⿱山.*儿, ⿱人儿\n#     debug ( IDLX.diagram_from_source '⿺辶〓' )\n#     ### 'u-cjk-xb/2a18d' 𪆍 ###\n#     debug ( IDLX.diagram_from_source '⿰⿹勹⿱从⿰个个鳥' )\n#     # debug ( IDLX.diagram_from_source '⿰⿹勹(⿱从⿰个个)鳥' )\n#     debug ( IDLX.diagram_from_source '⿰⿹勹(⿱从从⿰个个)鳥' )\n#     debug ( IDLX.diagram_from_source '⿰⿹勹(⿱从⿰个个个)鳥' )\n#     debug()\n#     debug IDLX.parse                  '⿰阝⿱甘罕'\n#     debug IDLX.diagram_from_source    '⿰阝⿱甘罕'\n#     debug IDLX.tokenlist_from_source  '⿰阝⿱甘罕'\n#     debug IDLX.tokentree_from_source  '⿰阝⿱甘罕'\n\n#   demo_glyph_conversion = ->\n#     #-----------------------------------------------------------------------------------------------------------\n#     # IDL.NCR.chr_from_cid_and_csg = ( cid, csg  ) -> @as_chr cid, { csg: csg }\n#     # #-----------------------------------------------------------------------------------------------------------\n#     # IDL.NCR.normalize_to_xncr = ( glyph ) ->\n#     #   # throw new Error \"do we need this method?\"\n#     #   cid = @as_cid glyph\n#     #   csg = if ( @as_rsg glyph ) is 'u-pua' then 'jzr' else @as_csg glyph\n#     #   return @chr_from_cid_and_csg cid, 'jzr'\n#     #-----------------------------------------------------------------------------------------------------------\n#     IDL.NCR.jzr_as_xncr = ( glyph ) ->\n#       nfo = @analyze glyph\n#       return glyph unless ( nfo.rsg is 'u-pua' ) or ( nfo.csg is 'jzr' )\n#       return @as_chr nfo.cid, { csg: 'jzr', }\n#     #-----------------------------------------------------------------------------------------------------------\n#     glyph       = \"&jzr#xe234;\"\n#     glyph_uchr  = IDL.NCR.jzr_as_uchr glyph\n#     glyph_r1    = IDL.NCR.jzr_as_xncr glyph\n#     glyph_r2    = IDL.NCR.jzr_as_xncr glyph_uchr\n#     debug '32900', [ glyph, glyph_uchr, glyph_r1, glyph_r2, ]\n#     debug '32900', IDL.NCR.jzr_as_xncr 'x'\n#   # demo_glyph_conversion()\n\n###\n\nneed tests for IDL.parse\n\n\nbasic version should not use mingkwai-ncr; instead, use\nSteven Levithan's XRegExp to confine valid components to\nnon-whitespace, non-meta codepoints\n\nallow meta codepoints as components when escaped?\n\nincorporate full set of JZR IDL operators\n\nIDL algebra\n\ncollect operator, component statistics while building the tokentree\n\n###\n\n\n\n\n\n\n\n"
  ]
}