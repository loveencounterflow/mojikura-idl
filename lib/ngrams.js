// Generated by CoffeeScript 2.0.1
(function() {
  //###########################################################################################################
  var CND, assign, badge, debug, first_of, help, info, last_of, pluck, rpr, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'KBM/MIXINS/IPC';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  // { IDL, IDLX, }            = require '../../../mojikura-idl'
  first_of = function(x) {
    return x[0];
  };

  last_of = function(x) {
    return x[x.length - 1];
  };

  assign = Object.assign;

  //-----------------------------------------------------------------------------------------------------------
  pluck = function(x, key, fallback) {
    var R;
    R = x[key];
    if (R === void 0) {
      R = fallback;
    }
    delete x[key];
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_relational_bigrams = function(formula) {
    var bigram, token;
    return (function() {
      var i, len, ref, results;
      ref = this.get_relational_bigrams_as_tokens(formula);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        bigram = ref[i];
        results.push(((function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = bigram.length; j < len1; j++) {
            token = bigram[j];
            results1.push(token.s);
          }
          return results1;
        })()).join(''));
      }
      return results;
    }).call(this);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_relational_bigrams_as_tokens = function(formula) {
    var R, _, first_element, first_operator, i, last_element, last_operator, len, operator, operators, prvs_token, start_token, stop_token, this_token, tokens;
    tokens = this.list_tokens(formula, {
      all_brackets: true
    });
    R = [];
    operators = [];
    prvs_token = null;
    // countdowns    = []
    //.........................................................................................................
    for (i = 0, len = tokens.length; i < len; i++) {
      this_token = tokens[i];
      this_token = assign({}, this_token);
      // debug '87900', rpr this_token
      switch (this_token.t) {
        case 'lbracket':
          null;
          break;
        case 'rbracket':
          operators.pop();
          prvs_token.o = last_of(operators);
          break;
        case 'binary_operator':
          operators.push(this_token);
          break;
        case 'unary_operator':
          operators.push(this_token);
          break;
        case 'component':
        case 'proxy':
          this_token.o = last_of(operators);
          if (prvs_token != null) {
            operator = pluck(prvs_token, 'o');
            R.push([operator, prvs_token, this_token]);
          }
          prvs_token = this_token;
          break;
        default:
          throw new Error(`unknown token type ${rpr(this_token)}`);
      }
    }
    //.........................................................................................................
    if (R.length > 0) {
      delete (last_of(last_of(R))).o;
      [/* ⊚⊙⎉⏵⏺⏹⏸ */ first_operator, first_element, _] = first_of(R);
      [last_operator, _, last_element] = last_of(R);
      start_token = {
        t: 'start',
        s: '⊚',
        i: null
      };
      stop_token = {
        t: 'stop',
        s: '⊚',
        i: null
      };
      R.unshift([first_operator, start_token, first_element]);
      R.push([last_operator, last_element, stop_token]);
    }
    //.........................................................................................................
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_relational_bigrams_as_indices = function(formula) {
    return this._indices_from_bigram_tokens(this.get_relational_bigrams_as_tokens(formula));
  };

  //-----------------------------------------------------------------------------------------------------------
  this._indices_from_bigram_tokens = function(bigrams) {
    var bigram, token;
    return (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = bigrams.length; i < len; i++) {
        bigram = bigrams[i];
        results.push((function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = bigram.length; j < len1; j++) {
            token = bigram[j];
            results1.push(token.i);
          }
          return results1;
        })());
      }
      return results;
    })();
  };

  //-----------------------------------------------------------------------------------------------------------
  this.split_formula = function(formula) {
    var token;
    return (function() {
      var i, len, ref, results;
      ref = this.list_tokens(formula);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        token = ref[i];
        results.push(token.s);
      }
      return results;
    }).call(this);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.bigrams_from_formula_and_indices = function(formula, bigrams_as_indices) {
    return this.bigrams_from_parts_and_indices(this.split_formula(formula), bigrams_as_indices);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.bigrams_from_parts_and_indices = function(parts, bigrams_as_indices) {
    var bigram_indices, idx;
    return (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = bigrams_as_indices.length; i < len; i++) {
        bigram_indices = bigrams_as_indices[i];
        results.push((function() {
          var j, len1, ref, results1;
          results1 = [];
          for (j = 0, len1 = bigram_indices.length; j < len1; j++) {
            idx = bigram_indices[j];
            results1.push((ref = parts[idx]) != null ? ref : '⊚');
          }
          return results1;
        })());
      }
      return results;
    })();
  };

}).call(this);

//# sourceMappingURL=ngrams.js.map
