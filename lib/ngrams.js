// Generated by CoffeeScript 2.0.1
(function() {
  //###########################################################################################################
  var CND, assign, badge, debug, help, info, last_of, pluck, rpr, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'KBM/MIXINS/IPC';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  // { IDL, IDLX, }            = require '../../../mojikura-idl'
  last_of = function(x) {
    return x[x.length - 1];
  };

  assign = Object.assign;

  //-----------------------------------------------------------------------------------------------------------
  pluck = function(x, key, fallback) {
    var R;
    R = x[key];
    if (R === void 0) {
      R = fallback;
    }
    delete x[key];
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT should be derived from options or grammar */
  this._unary_operator_pattern = /≈|<|>|\?|↻|↔|↕/g;

  //-----------------------------------------------------------------------------------------------------------
  this._delete_unary_operators = function(formula) {
    return formula.replace(this._unary_operator_pattern, '');
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_relational_bigrams_as_tokens = function(formula) {
    var R, error, i, j, len, operator, operators, prvs_token, this_token, tokens;
    formula = this._delete_unary_operators(formula);
    try {
      tokens = this.list_tokens(formula, {
        all_brackets: true
      });
    } catch (error1) {
      error = error1;
      if (error.message === `invalid syntax at index 0 (${formula})\nUnexpected "${formula}"\n`) {
        return [];
      }
      throw error;
    }
    //.........................................................................................................
    R = [];
    operators = [];
    prvs_token = null;
    for (i = j = 0, len = tokens.length; j < len; i = ++j) {
      this_token = tokens[i];
      this_token = assign({}, this_token, {i});
      switch (this_token.t) {
        case 'lbracket':
          null;
          break;
        case 'rbracket':
          operators.pop();
          prvs_token.o = last_of(operators);
          break;
        case 'binary_operator':
          operators.push(this_token);
          break;
        case 'component':
          this_token.o = last_of(operators);
          if (prvs_token != null) {
            operator = pluck(prvs_token, 'o');
            R.push([operator, prvs_token, this_token]);
          }
          prvs_token = this_token;
          break;
        default:
          throw new Error(`unknown token type ${rpr(this_token)}`);
      }
    }
    delete (last_of(last_of(R))).o;
    return R;
  };

}).call(this);

//# sourceMappingURL=ngrams.js.map
