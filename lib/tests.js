// Generated by CoffeeScript 1.10.0
(function() {
  var CND, IDL, IDLX, MKNCR, alert, badge, debug, demo_errors, echo, help, include, info, log, nice_text_rpr, ref, resume_next, rpr, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MOJIKURA-IDL/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  ref = require('./main'), IDL = ref.IDL, IDLX = ref.IDLX;

  MKNCR = require('mingkwai-ncr');

  nice_text_rpr = function(text) {

    /* Ad-hoc method to print out text in a readable, CoffeeScript-compatible, triple-quoted way. Line breaks
    (`\\n`) will be shown as line breaks, so texts should not be as spaghettified as they appear with
    JSON.stringify (the last line break of a string is, however, always shown in its symbolic form so it
    won't get swallowed by the CoffeeScript parser). Code points below U+0020 (space) are shown as
    `\\x00`-style escapes, taken up less space than `\u0000` escapes while keeping things explicit. All
    double quotes will be prepended with a backslash.
     */
    var R;
    R = text;
    R = R.replace(/[\x00-\x09\x0b-\x19]/g, function($0) {
      var cid_hex;
      cid_hex = ($0.codePointAt(0)).toString(16);
      if (cid_hex.length === 1) {
        cid_hex = '0' + cid_hex;
      }
      return "\\x" + cid_hex;
    });
    R = R.replace(/"/g, '\\"');
    R = R.replace(/\n$/g, '\\n');
    R = '\n"""' + R + '"""';
    return R;
  };

  this._main = function(handler) {
    return test(this, {
      'timeout': 2500
    });
  };

  this._prune = function() {
    var name, value;
    for (name in this) {
      value = this[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  resume_next = function(T, method) {
    var R, error, error1;
    try {
      R = method();
    } catch (error1) {
      error = error1;
      return Symbol("### ERROR ### " + error['message']);
    }
    return R;
  };

  this["sanity checks (private methods)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"]], ["⿲", ["assigned", "cjk", "idl"]], ["a", ["assigned"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDL._tags_from_symbol(null, probe);
      help(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["sanity checks (grammar data)"] = function(T) {
    T.ok('⿰' in IDL.grammar.operators);
    T.ok('⿱' in IDL.grammar.operators);
    T.ok('⿴' in IDL.grammar.operators);
    T.ok('⿵' in IDL.grammar.operators);
    T.ok('⿶' in IDL.grammar.operators);
    T.ok('⿷' in IDL.grammar.operators);
    T.ok('⿸' in IDL.grammar.operators);
    T.ok('⿹' in IDL.grammar.operators);
    T.ok('⿺' in IDL.grammar.operators);
    T.ok('⿻' in IDL.grammar.operators);
    T.ok('⿲' in IDL.grammar.operators);
    T.ok('⿳' in IDL.grammar.operators);
    T.ok('⿰' in IDLX.grammar.operators);
    T.ok('⿱' in IDLX.grammar.operators);
    T.ok('⿴' in IDLX.grammar.operators);
    T.ok('⿵' in IDLX.grammar.operators);
    T.ok('⿶' in IDLX.grammar.operators);
    T.ok('⿷' in IDLX.grammar.operators);
    T.ok('⿸' in IDLX.grammar.operators);
    T.ok('⿹' in IDLX.grammar.operators);
    T.ok('⿺' in IDLX.grammar.operators);
    T.ok('⿻' in IDLX.grammar.operators);
    T.ok(!('⿲' in IDLX.grammar.operators));
    T.ok(!('⿳' in IDLX.grammar.operators));
    T.ok('◰' in IDLX.grammar.operators);
    T.ok('≈' in IDLX.grammar.operators);
    T.ok('↻' in IDLX.grammar.operators);
    T.ok('↔' in IDLX.grammar.operators);
    T.ok('↕' in IDLX.grammar.operators);
    T.ok('●' in IDLX.grammar.solitaires);
    T.ok(IDL.grammar !== IDLX.grammar);
    T.ok(IDL.grammar.operators !== IDLX.grammar.operators);
    T.ok(!CND.equals(IDL.grammar, IDLX.grammar));
    T.ok(!CND.equals(IDL.grammar.operators, IDLX.grammar.operators));
    return null;
  };

  this["sanity checks (MKNCR)"] = function(T) {
    var csg, description, i, len, matcher, probe, probes_and_matchers, ref1, result, tag;
    probes_and_matchers = [["⿲", ["u", ["assigned", "cjk", "idl"]]], ["木", ["u", ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"]]], ["&#x1234;", ["u", ["assigned"]]], ["&#xe100;", ["u", ["assigned", "pua", "cjk"]]], ["&jzr#xe100;", ["jzr", ["assigned", "cjk"]]], ["&morohashi#x1234;", ["morohashi", ["assigned", "cjk"]]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      description = MKNCR.describe(probe);
      csg = description.csg, tag = description.tag;
      result = [csg, tag];
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) parse simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿲木木木", ["⿲", "木", "木", "木"]], ["⿱癶⿰弓貝", ["⿱", "癶", ["⿰", "弓", "貝"]]], ["⿱⿰亻式貝", ["⿱", ["⿰", "亻", "式"], "貝"]], ["⿱⿰亻式⿱目八", ["⿱", ["⿰", "亻", "式"], ["⿱", "目", "八"]]], ["⿺辶言", ["⿺", "辶", "言"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDL.parse(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) parse tree of simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [
      [
        "⿲木木木", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿲",
            "idx": 0,
            "t": "operator",
            "a": 3,
            "n": "pillars"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 1,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 2,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 3,
            "t": "component"
          }
        ]
      ], [
        "⿱癶⿰弓貝", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "癶",
            "idx": 1,
            "t": "component"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 2,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "弓",
              "idx": 3,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "貝",
              "idx": 4,
              "t": "component"
            }
          ]
        ]
      ], [
        "⿱⿰亻式貝", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 1,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "亻",
              "idx": 2,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "式",
              "idx": 3,
              "t": "component"
            }
          ], {
            "~isa": "MOJIKURA-IDL/token",
            "s": "貝",
            "idx": 4,
            "t": "component"
          }
        ]
      ], [
        "⿱⿰亻式⿱目八", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 1,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "亻",
              "idx": 2,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "式",
              "idx": 3,
              "t": "component"
            }
          ], [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿱",
              "idx": 4,
              "t": "operator",
              "a": 2,
              "n": "top/down"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "目",
              "idx": 5,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "八",
              "idx": 6,
              "t": "component"
            }
          ]
        ]
      ], [
        "⿺辶言", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿺",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "leftbottom"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "辶",
            "idx": 1,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "言",
            "idx": 2,
            "t": "component"
          }
        ]
      ]
    ];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDL.parse_tree(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) reject bogus formulas"] = function(T) {
    var error, error1, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", "syntax error: lone token of type 'component' in [  ✘ 木 ✘  ]"], [42, "expected a text, got a number"], ["", "syntax error: empty text"], ["⿱⿰亻式⿱目八木木木", "syntax error: extra token(s) in [ ⿱⿰亻式⿱目八 ✘ 木 ✘ 木木 ]"], ["⿺廴聿123", "syntax error: extra token(s) in [ ⿺廴聿 ✘ 1 ✘ 23 ]"], ["⿺", "syntax error: premature end of source in [  ✘ ⿺ ✘  ])"], ["⿺⿺⿺⿺", "syntax error: premature end of source in [ ⿺⿺⿺ ✘ ⿺ ✘  ])"], ["⿺12", "syntax error: illegal token '1' (type 'other') in [ ⿺ ✘ 1 ✘ 2 ]"], ["(⿰亻聿式)", "syntax error: illegal token '(' (type 'other') in [  ✘ ( ✘ ⿰亻聿式) ]"], ["≈〇", "syntax error: illegal token '≈' (type 'other') in [  ✘ ≈ ✘ 〇 ]"], ["●", "syntax error: illegal token '●' (type 'other') in [  ✘ ● ✘  ]"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDL.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
        T.eq(message, matcher);
      }
    }
    return null;
  };

  this["(IDLX) parse simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿱癶⿰弓貝", ["⿱", "癶", ["⿰", "弓", "貝"]]], ["⿱⿰亻式貝", ["⿱", ["⿰", "亻", "式"], "貝"]], ["⿱⿰亻式⿱目八", ["⿱", ["⿰", "亻", "式"], ["⿱", "目", "八"]]], ["⿺辶言", ["⿺", "辶", "言"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDLX.parse(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) reject bogus formulas"] = function(T) {
    var error, error1, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", "syntax error: lone token of type 'component' in [  ✘ 木 ✘  ]"], [42, "expected a text, got a number"], ["", "syntax error: empty text"], ["⿱⿰亻式⿱目八木木木", "syntax error: extra token(s) in [ ⿱⿰亻式⿱目八 ✘ 木 ✘ 木木 ]"], ["⿺廴聿123", "syntax error: extra token(s) in [ ⿺廴聿 ✘ 1 ✘ 23 ]"], ["⿺", "syntax error: premature end of source in [  ✘ ⿺ ✘  ])"], ["⿺⿺⿺⿺", "syntax error: premature end of source in [ ⿺⿺⿺ ✘ ⿺ ✘  ])"], ["⿺12", "syntax error: illegal token '1' (type 'other') in [ ⿺ ✘ 1 ✘ 2 ]"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
        T.eq(message, matcher);
      }
    }
    return null;
  };

  this["(IDLX) reject IDL operators with arity 3"] = function(T) {
    var error, error1, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿲木木木", "syntax error: extra token(s) in [ ⿲ ✘ 木 ✘ 木木 ]"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
        T.eq(message, matcher);
      }
    }
    return null;
  };

  this["(IDLX) parse extended formulas (plain)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [['≈㐀', ['≈', '㐀']], ['≈𠀎', ['≈', '𠀎']], ['≈𪜀', ['≈', '𪜀']], ['≈〇', ['≈', '〇']], ['●', '●'], ['〓', '〓'], ['⿱〓〓', ['⿱', '〓', '〓']], ['▽', '▽'], ['↻正', ['↻', '正']], ['↔≈匕', ['↔', ['≈', '匕']]], ['↔正', ['↔', '正']], ['⿱丶乂', ['⿱', '丶', '乂']], ['⿺走⿹◰口戈日', ['⿺', '走', ['⿹', ['◰', '口', '戈'], '日']]], ['≈匚', ['≈', '匚']], ["≈&jzr#xe174;", ["≈", ""]], ['≈非', ['≈', '非']], ['⿺走⿹◰口〓日', ['⿺', '走', ['⿹', ['◰', '口', '〓'], '日']]], ["⿻串⿰立&jzr#x1234;", ["⿻", "串", ["⿰", "立", "ሴ"]]], ["⿱丶⿵𠘨§", ["⿱", "丶", ["⿵", "𠘨", "§"]]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDLX.parse(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) parse extended formulas (bracketed)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [['⿰亻聿', ['⿰', '亻', '聿']], ['(⿰亻聿式)', ['⿰', '亻', '聿', '式']]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDLX.parse(probe);
      urge(JSON.stringify([probe, result]));
    }
    return null;
  };

  this["(IDLX) reject bogus bracketed formulas"] = function(T) {
    var error, error1, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [['(⿰亻聿)', ""], ['(⿰亻)', ""], ['(⿰亻)聿', ""]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
      }
    }
    return null;
  };

  if (module.parent == null) {
    include = ["(IDLX) parse extended formulas (bracketed)"];
    this._prune();
    info(IDLX.parse('⿰亻聿'));
    info(IDLX.parse('(⿰亻聿式)'));
    demo_errors = function() {
      var d, error, error1, i, len, results, source, sources;
      sources = ["", "⿺", "走", "走⿹◰口弓戈〓", "⿺走x", "⿺走⿹◰口弓戈〓"];
      results = [];
      for (i = 0, len = sources.length; i < len; i++) {
        source = sources[i];
        try {
          results.push(d = IDLX.parse_tree(source));
        } catch (error1) {
          error = error1;
          results.push(info(error['message']));
        }
      }
      return results;
    };
  }


  /*
  
  
  use PipeDreams tap to implement benchmarks
  
  detect bogus occurrences of solitaires in non-minimal formulas
  
  remove stack and other unused properties of _new_parse
  
  implement brackets
   */

}).call(this);

//# sourceMappingURL=tests.js.map
