// Generated by CoffeeScript 1.10.0
(function() {
  var CND, IDL, IDLX, alert, badge, d, debug, echo, error, error1, help, i, include, info, len, log, nice_text_rpr, ref, rpr, source, sources, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MOJIKURA-IDL/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  ref = require('./main'), IDL = ref.IDL, IDLX = ref.IDLX;

  nice_text_rpr = function(text) {

    /* Ad-hoc method to print out text in a readable, CoffeeScript-compatible, triple-quoted way. Line breaks
    (`\\n`) will be shown as line breaks, so texts should not be as spaghettified as they appear with
    JSON.stringify (the last line break of a string is, however, always shown in its symbolic form so it
    won't get swallowed by the CoffeeScript parser). Code points below U+0020 (space) are shown as
    `\\x00`-style escapes, taken up less space than `\u0000` escapes while keeping things explicit. All
    double quotes will be prepended with a backslash.
     */
    var R;
    R = text;
    R = R.replace(/[\x00-\x09\x0b-\x19]/g, function($0) {
      var cid_hex;
      cid_hex = ($0.codePointAt(0)).toString(16);
      if (cid_hex.length === 1) {
        cid_hex = '0' + cid_hex;
      }
      return "\\x" + cid_hex;
    });
    R = R.replace(/"/g, '\\"');
    R = R.replace(/\n$/g, '\\n');
    R = '\n"""' + R + '"""';
    return R;
  };

  this._main = function(handler) {
    return test(this, {
      'timeout': 2500
    });
  };

  this._prune = function() {
    var name, value;
    for (name in this) {
      value = this[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  this["sanity checks (private methods)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"]], ["⿲", ["assigned", "cjk", "idl"]], ["a", ["assigned"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDL._tags_from_symbol(null, probe);
      help(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["sanity checks (grammar data)"] = function(T) {
    T.ok('⿰' in IDL.grammar.operators);
    T.ok('⿱' in IDL.grammar.operators);
    T.ok('⿴' in IDL.grammar.operators);
    T.ok('⿵' in IDL.grammar.operators);
    T.ok('⿶' in IDL.grammar.operators);
    T.ok('⿷' in IDL.grammar.operators);
    T.ok('⿸' in IDL.grammar.operators);
    T.ok('⿹' in IDL.grammar.operators);
    T.ok('⿺' in IDL.grammar.operators);
    T.ok('⿻' in IDL.grammar.operators);
    T.ok('⿲' in IDL.grammar.operators);
    T.ok('⿳' in IDL.grammar.operators);
    T.ok('⿰' in IDLX.grammar.operators);
    T.ok('⿱' in IDLX.grammar.operators);
    T.ok('⿴' in IDLX.grammar.operators);
    T.ok('⿵' in IDLX.grammar.operators);
    T.ok('⿶' in IDLX.grammar.operators);
    T.ok('⿷' in IDLX.grammar.operators);
    T.ok('⿸' in IDLX.grammar.operators);
    T.ok('⿹' in IDLX.grammar.operators);
    T.ok('⿺' in IDLX.grammar.operators);
    T.ok('⿻' in IDLX.grammar.operators);
    T.ok(!('⿲' in IDLX.grammar.operators));
    T.ok(!('⿳' in IDLX.grammar.operators));
    T.ok('◰' in IDLX.grammar.operators);
    T.ok('≈' in IDLX.grammar.operators);
    T.ok('↻' in IDLX.grammar.operators);
    T.ok('↔' in IDLX.grammar.operators);
    T.ok('↕' in IDLX.grammar.operators);
    T.ok('●' in IDLX.grammar.solitaires);
    T.ok(IDL.grammar !== IDLX.grammar);
    T.ok(IDL.grammar.operators !== IDLX.grammar.operators);
    T.ok(!CND.equals(IDL.grammar, IDLX.grammar));
    T.ok(!CND.equals(IDL.grammar.operators, IDLX.grammar.operators));
    return null;
  };

  this["(IDL) parse simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿲木木木", ["⿲", "木", "木", "木"]], ["⿱癶⿰弓貝", ["⿱", "癶", ["⿰", "弓", "貝"]]], ["⿱⿰亻式貝", ["⿱", ["⿰", "亻", "式"], "貝"]], ["⿱⿰亻式⿱目八", ["⿱", ["⿰", "亻", "式"], ["⿱", "目", "八"]]], ["⿺辶言", ["⿺", "辶", "言"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDL.parse(probe);
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) parse tree of simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [
      [
        "⿲木木木", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿲",
            "idx": 0,
            "t": "operator",
            "a": 3,
            "n": "pillars"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 1,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 2,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 3,
            "t": "component"
          }
        ]
      ], [
        "⿱癶⿰弓貝", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "癶",
            "idx": 1,
            "t": "component"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 2,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "弓",
              "idx": 3,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "貝",
              "idx": 4,
              "t": "component"
            }
          ]
        ]
      ], [
        "⿱⿰亻式貝", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 1,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "亻",
              "idx": 2,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "式",
              "idx": 3,
              "t": "component"
            }
          ], {
            "~isa": "MOJIKURA-IDL/token",
            "s": "貝",
            "idx": 4,
            "t": "component"
          }
        ]
      ], [
        "⿱⿰亻式⿱目八", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 1,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "亻",
              "idx": 2,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "式",
              "idx": 3,
              "t": "component"
            }
          ], [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿱",
              "idx": 4,
              "t": "operator",
              "a": 2,
              "n": "top/down"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "目",
              "idx": 5,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "八",
              "idx": 6,
              "t": "component"
            }
          ]
        ]
      ], [
        "⿺辶言", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿺",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "leftbottom"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "辶",
            "idx": 1,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "言",
            "idx": 2,
            "t": "component"
          }
        ]
      ]
    ];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDL.parse_tree(probe);
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) reject bogus formulas"] = function(T) {
    var error, error1, i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", "syntax error:  lone token of type 'component' in '木'"], [42, "expected a text, got a number"], ["", "syntax error (empty text)"], ["⿱⿰亻式⿱目八木木木", "syntax error (token idx 7 of '⿱⿰亻式⿱目八木木木')"], ["⿺廴聿123", "syntax error (token idx 3 of '⿺廴聿123')"], ["⿺", "syntax error (premature end of source '⿺')"], ["⿺⿺⿺⿺", "syntax error (premature end of source '⿺⿺⿺⿺')"], ["⿺12", "unable to parse token of type 'other' (token idx 2 of '⿺12')"], ["(⿰亻聿式)", "unable to parse token of type 'other' (token idx 1 of '(⿰亻聿式)')"], ["≈〇", "unable to parse token of type 'other' (token idx 1 of '≈〇')"], ["●", "unable to parse token of type 'other' (token idx 1 of '●')"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDL.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        warn(JSON.stringify([probe, error['message']]));
        T.eq(error['message'], matcher);
      }
    }
    return null;
  };

  this["(IDLX) parse simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿱癶⿰弓貝", ["⿱", "癶", ["⿰", "弓", "貝"]]], ["⿱⿰亻式貝", ["⿱", ["⿰", "亻", "式"], "貝"]], ["⿱⿰亻式⿱目八", ["⿱", ["⿰", "亻", "式"], ["⿱", "目", "八"]]], ["⿺辶言", ["⿺", "辶", "言"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDLX.parse(probe);
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) reject bogus formulas"] = function(T) {
    var error, error1, i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", "syntax error:  lone token of type 'component' in '木'"], [42, "expected a text, got a number"], ["", "syntax error (empty text)"], ["⿱⿰亻式⿱目八木木木", "syntax error (token idx 7 of '⿱⿰亻式⿱目八木木木')"], ["⿺廴聿123", "syntax error (token idx 3 of '⿺廴聿123')"], ["⿺", "syntax error (premature end of source '⿺')"], ["⿺⿺⿺⿺", "syntax error (premature end of source '⿺⿺⿺⿺')"], ["⿺12", "unable to parse token of type 'other' (token idx 2 of '⿺12')"], ["(⿰亻聿式)", "unable to parse token of type 'other' (token idx 1 of '(⿰亻聿式)')"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        warn(JSON.stringify([probe, error['message']]));
        T.eq(error['message'], matcher);
      }
    }
    return null;
  };

  this["(IDLX) reject IDL operators with arity 3"] = function(T) {
    var error, error1, i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿲木木木", "syntax error (token idx 1 of '⿲木木木')"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        warn(JSON.stringify([probe, error['message']]));
        T.eq(error['message'], matcher);
      }
    }
    return null;
  };

  this["(IDLX) parse extended formulas (plain)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [['≈㐀', ['≈', '㐀']], ['≈𠀎', ['≈', '𠀎']], ['≈𪜀', ['≈', '𪜀']], ['≈〇', ['≈', '〇']], ['●', '●'], ['〓', '〓'], ['⿱〓〓', ['⿱', '〓', '〓']], ['▽', '▽'], ['↻正', ['↻', '正']], ['↔≈匕', ['↔', ['≈', '匕']]], ['↔正', ['↔', '正']], ['⿱丶乂', ['⿱', '丶', '乂']], ['⿺走⿹◰口戈日', ['⿺', '走', ['⿹', ['◰', '口', '戈'], '日']]], ['≈匚', ['≈', '匚']], ['≈&jzr#xe174;', ['≈', '&jzr#xe174;']], ['≈非', ['≈', '非']], ['⿺走⿹◰口〓日', ['⿺', '走', ['⿹', ['◰', '口', '〓'], '日']]], ['⿻串⿰立&jzr#x1234;', ['⿻', '串', ['⿰', '立', '&jzr#x1234;']]], ['⿱丶⿵𠘨§', ['⿱', '§', '&jzr#xe199;']]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDLX.parse(probe);
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) parse extended formulas (bracketed)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [['(⿱北㓁允)', ['⿱', ['北', '㓁', '允']]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDLX.parse(probe);
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  if (module.parent == null) {
    include = ["sanity checks (private methods)", "sanity checks (grammar data)", "(IDL) parse simple formulas", "(IDL) parse tree of simple formulas", "(IDL) reject bogus formulas", "(IDLX) parse simple formulas", "(IDLX) reject bogus formulas", "(IDLX) reject IDL operators with arity 3", "(IDLX) parse extended formulas (plain)"];
    this._prune();
    sources = ["⿺", "走", "走⿹◰口弓戈〓", "⿺走x", "⿺走⿹◰口弓戈〓"];
    for (i = 0, len = sources.length; i < len; i++) {
      source = sources[i];
      try {
        d = IDLX.parse_tree(source);
      } catch (error1) {
        error = error1;
        info(error['message']);
      }
    }
  }


  /*
  
  what's wrong with
        [ '⿻串⿰立&jzr#x1234;', [ '⿻', '串', [ '⿰', '立', '&jzr#x1234;' ] ], ]
  
  use custom toString, colors for error display
  
  implement "on error resume next" method for exhaustive testing even with failing tests
  
  use PipeDreams tap to implement benchmarks
  
  detect bogus occurrences of solitaires in non-minimal formulas
  
  remove stack and other unused properties of _new_parse
   */

}).call(this);

//# sourceMappingURL=tests.js.map
