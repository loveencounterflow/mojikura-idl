// Generated by CoffeeScript 1.12.4
(function() {
  var CND, IDL, IDLX, alert, badge, debug, demo_glyph_conversion, demo_new_api, echo, help, include, info, log, nice_text_rpr, ref, resume_next, rpr, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MOJIKURA-IDL/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  ref = require('./main'), IDL = ref.IDL, IDLX = ref.IDLX;

  nice_text_rpr = function(text) {

    /* Ad-hoc method to print out text in a readable, CoffeeScript-compatible, triple-quoted way. Line breaks
    (`\\n`) will be shown as line breaks, so texts should not be as spaghettified as they appear with
    JSON.stringify (the last line break of a string is, however, always shown in its symbolic form so it
    won't get swallowed by the CoffeeScript parser). Code points below U+0020 (space) are shown as
    `\\x00`-style escapes, taken up less space than `\u0000` escapes while keeping things explicit. All
    double quotes will be prepended with a backslash.
     */
    var R;
    R = text;
    R = R.replace(/[\x00-\x09\x0b-\x19]/g, function($0) {
      var cid_hex;
      cid_hex = ($0.codePointAt(0)).toString(16);
      if (cid_hex.length === 1) {
        cid_hex = '0' + cid_hex;
      }
      return "\\x" + cid_hex;
    });
    R = R.replace(/"/g, '\\"');
    R = R.replace(/\n$/g, '\\n');
    R = '\n"""' + R + '"""';
    return R;
  };

  this._main = function(handler) {
    return test(this, {
      'timeout': 2500
    });
  };

  this._prune = function() {
    var name, ref1, value;
    ref1 = this;
    for (name in ref1) {
      value = ref1[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  resume_next = function(T, method) {
    var R, error;
    try {
      R = method();
    } catch (error1) {
      error = error1;
      return Symbol("### ERROR ### " + error['message']);
    }
    return R;
  };

  this["sanity checks (grammar data)"] = function(T) {
    T.ok('⿰' in IDL._parser_settings.operators);
    T.ok('⿱' in IDL._parser_settings.operators);
    T.ok('⿴' in IDL._parser_settings.operators);
    T.ok('⿵' in IDL._parser_settings.operators);
    T.ok('⿶' in IDL._parser_settings.operators);
    T.ok('⿷' in IDL._parser_settings.operators);
    T.ok('⿸' in IDL._parser_settings.operators);
    T.ok('⿹' in IDL._parser_settings.operators);
    T.ok('⿺' in IDL._parser_settings.operators);
    T.ok('⿻' in IDL._parser_settings.operators);
    T.ok('⿲' in IDL._parser_settings.operators);
    T.ok('⿳' in IDL._parser_settings.operators);
    T.ok('⿰' in IDLX._parser_settings.operators);
    T.ok('⿱' in IDLX._parser_settings.operators);
    T.ok('⿴' in IDLX._parser_settings.operators);
    T.ok('⿵' in IDLX._parser_settings.operators);
    T.ok('⿶' in IDLX._parser_settings.operators);
    T.ok('⿷' in IDLX._parser_settings.operators);
    T.ok('⿸' in IDLX._parser_settings.operators);
    T.ok('⿹' in IDLX._parser_settings.operators);
    T.ok('⿺' in IDLX._parser_settings.operators);
    T.ok('⿻' in IDLX._parser_settings.operators);
    T.ok(!('⿲' in IDLX._parser_settings.operators));
    T.ok(!('⿳' in IDLX._parser_settings.operators));
    T.ok('◰' in IDLX._parser_settings.operators);
    T.ok('≈' in IDLX._parser_settings.operators);
    T.ok('↻' in IDLX._parser_settings.operators);
    T.ok('↔' in IDLX._parser_settings.operators);
    T.ok('↕' in IDLX._parser_settings.operators);
    T.ok('●' in IDLX._parser_settings.solitaires);
    T.ok(IDL._parser_settings !== IDLX._parser_settings);
    T.ok(IDL._parser_settings.operators !== IDLX._parser_settings.operators);
    T.ok(!CND.equals(IDL._parser_settings, IDLX._parser_settings));
    T.ok(!CND.equals(IDL._parser_settings.operators, IDLX._parser_settings.operators));
    return null;
  };

  this["(IDL) parse simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿲木木木", ["⿲", "木", "木", "木"]], ["⿱癶⿰弓貝", ["⿱", "癶", ["⿰", "弓", "貝"]]], ["⿱⿰亻式貝", ["⿱", ["⿰", "亻", "式"], "貝"]], ["⿱⿰亻式⿱目八", ["⿱", ["⿰", "亻", "式"], ["⿱", "目", "八"]]], ["⿺辶言", ["⿺", "辶", "言"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDL.diagram_from_source(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) parse tree of simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [
      [
        "⿲木木木", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿲",
            "idx": 0,
            "t": "operator",
            "a": 3,
            "n": "pillars"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 1,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 2,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 3,
            "t": "component"
          }
        ]
      ], [
        "⿱癶⿰弓貝", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "癶",
            "idx": 1,
            "t": "component"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 2,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "弓",
              "idx": 3,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "貝",
              "idx": 4,
              "t": "component"
            }
          ]
        ]
      ], [
        "⿱⿰亻式貝", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 1,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "亻",
              "idx": 2,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "式",
              "idx": 3,
              "t": "component"
            }
          ], {
            "~isa": "MOJIKURA-IDL/token",
            "s": "貝",
            "idx": 4,
            "t": "component"
          }
        ]
      ], [
        "⿱⿰亻式⿱目八", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 1,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "亻",
              "idx": 2,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "式",
              "idx": 3,
              "t": "component"
            }
          ], [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿱",
              "idx": 4,
              "t": "operator",
              "a": 2,
              "n": "top/down"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "目",
              "idx": 5,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "八",
              "idx": 6,
              "t": "component"
            }
          ]
        ]
      ], [
        "⿺辶言", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿺",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "leftbottom"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "辶",
            "idx": 1,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "言",
            "idx": 2,
            "t": "component"
          }
        ]
      ]
    ];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDL.tokentree_from_source(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) reject bogus formulas"] = function(T) {
    var error, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", "IDL: lone token of type 'component' [  ✘ 木 ✘  ]"], [42, "expected a text, got a number"], ["", "IDL: empty text"], ["⿱⿰亻式⿱目八木木木", "IDL: extra token(s) [ ⿱⿰亻式⿱目八 ✘ 木 ✘ 木木 ]"], ["⿺廴聿123", "IDL: extra token(s) [ ⿺廴聿 ✘ 1 ✘ 23 ]"], ["⿺", "IDL: premature end of source [  ✘ ⿺ ✘  ]"], ["⿺⿺⿺⿺", "IDL: premature end of source [ ⿺⿺⿺ ✘ ⿺ ✘  ]"], ["(⿰亻聿式)", "IDL: extra token(s) [ ( ✘ ⿰ ✘ 亻聿式) ]"], ["≈〇", "IDL: extra token(s) [ ≈ ✘ 〇 ✘  ]"], ["●", "IDL: lone token of type 'component' [  ✘ ● ✘  ]"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDL.diagram_from_source(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
      }
    }
    return null;
  };

  this["(IDLX) parse simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿱癶⿰弓貝", ["⿱", "癶", ["⿰", "弓", "貝"]]], ["⿱⿰亻式貝", ["⿱", ["⿰", "亻", "式"], "貝"]], ["⿱⿰亻式⿱目八", ["⿱", ["⿰", "亻", "式"], ["⿱", "目", "八"]]], ["⿺辶言", ["⿺", "辶", "言"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDLX.diagram_from_source(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) reject bogus formulas"] = function(T) {
    var error, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", "IDL: lone token of type 'component' [  ✘ 木 ✘  ]"], [42, "expected a text, got a number"], ["", "IDL: empty text"], ["⿱⿰亻式⿱目八木木木", "IDL: extra token(s) [ ⿱⿰亻式⿱目八 ✘ 木 ✘ 木木 ]"], ["⿺廴聿123", "IDL: extra token(s) [ ⿺廴聿 ✘ 1 ✘ 23 ]"], ["⿺", "IDLX: premature end of source [  ✘ ⿺ ✘  ]"], ["⿺⿺⿺⿺", "IDLX: premature end of source [ ⿺⿺⿺ ✘ ⿺ ✘  ]"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.diagram_from_source(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
        T.eq(message, matcher);
      }
    }
    return null;
  };

  this["(IDLX) reject IDL operators with arity 3"] = function(T) {
    var error, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿲木木木", "IDL: extra token(s) [ ⿲ ✘ 木 ✘ 木木 ]"], ["⿳木木木", "IDL: extra token(s) [ ⿳ ✘ 木 ✘ 木木 ]"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.diagram_from_source(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
        T.eq(message, matcher);
      }
    }
    return null;
  };

  this["(IDLX) parse extended formulas (plain)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [['≈㐀', ['≈', '㐀']], ['≈𠀎', ['≈', '𠀎']], ['≈𪜀', ['≈', '𪜀']], ['≈〇', ['≈', '〇']], ['●', '●'], ['〓', '〓'], ['⿱〓〓', ['⿱', '〓', '〓']], ['▽', '▽'], ['↻正', ['↻', '正']], ['↔≈匕', ['↔', ['≈', '匕']]], ['↔正', ['↔', '正']], ['⿱丶乂', ['⿱', '丶', '乂']], ['⿺走⿹◰口戈日', ['⿺', '走', ['⿹', ['◰', '口', '戈'], '日']]], ['≈匚', ['≈', '匚']], ["≈&jzr#xe174;", ["≈", ""]], ['≈非', ['≈', '非']], ['⿺走⿹◰口〓日', ['⿺', '走', ['⿹', ['◰', '口', '〓'], '日']]], ["⿻串⿰立&jzr#x1234;", ["⿻", "串", ["⿰", "立", "ሴ"]]], ["⿱丶⿵𠘨§", ["⿱", "丶", ["⿵", "𠘨", "§"]]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDLX.diagram_from_source(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) parse extended formulas (bracketed)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["(⿰亻聿式)", ["⿰", "亻", "聿", "式"]], ["(⿱北㓁允)", ["⿱", "北", "㓁", "允"]], ["⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人人丨))", ["⿹", "弓", ["⿰", ["⿱", "人", "人", "丨"], ["⿱", "人", "人", "丨"], ["⿱", "人", "人", "丨"]]]], ["(⿱&jzr#xe223;一八⿰(⿱&jzr#xe223;一八)(⿱&jzr#xe223;一八))", ["⿱", "", "一", "八", ["⿰", ["⿱", "", "一", "八"], ["⿱", "", "一", "八"]]]], ["⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人人丨))", ["⿹", "弓", ["⿰", ["⿱", "人", "人", "丨"], ["⿱", "人", "人", "丨"], ["⿱", "人", "人", "丨"]]]], ["⿰臣(⿱𠂉(⿰人人人)(⿰古古古))", ["⿰", "臣", ["⿱", "𠂉", ["⿰", "人", "人", "人"], ["⿰", "古", "古", "古"]]]], ["(⿱屮(⿰屮屮屮)一(⿰𠂈屮又))", ["⿱", "屮", ["⿰", "屮", "屮", "屮"], "一", ["⿰", "𠂈", "屮", "又"]]], ["⿱(⿰車(⿱爫龴⿵冂厶)車)(⿰田⿵冂乂田)", ["⿱", ["⿰", "車", ["⿱", "爫", "龴", ["⿵", "冂", "厶"]], "車"], ["⿰", "田", ["⿵", "冂", "乂"], "田"]]], ["(⿰阝(⿸𠂆虍人)(⿸𠂆虍人))", ["⿰", "阝", ["⿸", "𠂆", "虍", "人"], ["⿸", "𠂆", "虍", "人"]]], ["⿰阝(⿱山人儿⿰(⿱山人儿)(⿱山人儿))", ["⿰", "阝", ["⿱", "山", "人", "儿", ["⿰", ["⿱", "山", "人", "儿"], ["⿱", "山", "人", "儿"]]]]], ["⿰阜(⿱山介⿰(⿱山人几)(⿱山人几))", ["⿰", "阜", ["⿱", "山", "介", ["⿰", ["⿱", "山", "人", "几"], ["⿱", "山", "人", "几"]]]]], ["(⿱厶(⿰刃工刃)一(⿰丶丶丶)口)", ["⿱", "厶", ["⿰", "刃", "工", "刃"], "一", ["⿰", "丶", "丶", "丶"], "口"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDLX.diagram_from_source(probe);
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) reject bogus formulas (bracketed)"] = function(T) {
    var error, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["()", "IDLX: unexpected right bracket [ ( ✘ ) ✘  ]"], ["(⿰)", "IDLX: too few constituents [ (⿰ ✘ ) ✘  ]"], ["(聿)", "IDL: extra token(s) [ (聿 ✘ ) ✘  ]"], [")", "IDLX: unexpected right bracket [  ✘ ) ✘  ]"], ["⿰)", "IDLX: unexpected right bracket [ ⿰ ✘ ) ✘  ]"], ["聿)", "IDL: extra token(s) [ 聿 ✘ ) ✘  ]"], ["(⿰亻聿)", "IDLX: too few constituents [ (⿰亻聿 ✘ ) ✘  ]"], ["(⿰亻)", "IDLX: too few constituents [ (⿰亻 ✘ ) ✘  ]"], ["(⿰亻)聿", "IDLX: too few constituents [ (⿰亻 ✘ ) ✘ 聿 ]"], ["(≈北㓁)", "IDLX: cannot bracket unary operator [ ( ✘ ≈ ✘ 北㓁) ]"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.diagram_from_source(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
        T.eq(message, matcher);
      }
    }
    return null;
  };

  this["(IDLX) reject bogus formulas (solitaires)"] = function(T) {
    var error, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿱〓▽", "IDLX: cannot have a solitaire here [ ⿱〓 ✘ ▽ ✘  ]"], ["↻●", "IDLX: cannot have a solitaire here [ ↻ ✘ ● ✘  ]"], ["↔≈▽", "IDLX: cannot have a solitaire here [ ↔≈ ✘ ▽ ✘  ]"], ["●亻", "IDLX: cannot have a solitaire here [  ✘ ● ✘ 亻 ]"], ["(●亻式)", "IDLX: cannot have a solitaire here [ ( ✘ ● ✘ 亻式) ]"], ["(⿰亻●式)", "IDLX: cannot have a solitaire here [ (⿰亻 ✘ ● ✘ 式) ]"], ["(⿱▽㓁允)", "IDLX: cannot have a solitaire here [ (⿱ ✘ ▽ ✘ 㓁允) ]"], ["⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人●丨))", "IDLX: cannot have a solitaire here [ ⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人 ✘ ● ✘ 丨)) ]"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.diagram_from_source(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
        T.eq(message, matcher);
      }
    }
    return null;
  };

  this["(IDL) _tokentree_as_formula"] = function(T) {
    var ctx, i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿲木木木", "⿲木木木"], ["⿱癶⿰弓貝", "⿱癶⿰弓貝"], ["⿱⿰亻式貝", "⿱⿰亻式貝"], ["⿱⿰亻式⿱目八", "⿱⿰亻式⿱目八"], ["⿺辶言", "⿺辶言"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      ctx = IDL.parse(probe);
      result = IDL._tokentree_as_formula(ctx, ctx.tokentree, 'uchr');
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) _tokentree_as_formula"] = function(T) {

    /* TAINT configurables:
    * whether to render JZR codepoints as PUA codepoints or as XNCRs
    * whether to fix systematic IDL blunders such as ⿺辶言
    * other normalizations (e.g. order of operators / terms)?
     */
    var ctx, i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿺辶言", "⿺辶言"], ["⿺辶〓", "⿺辶〓"], ["●", "●"], ["〓", "〓"], ["⿱癶⿰弓貝", "⿱癶⿰弓貝"], ["⿱⿰亻式貝", "⿱⿰亻式貝"], ["⿱⿰亻式⿱目八", "⿱⿰亻式⿱目八"], ["▽", "▽"], ["≈〇", "≈〇"], ["⿱〓〓", "⿱〓〓"], ["↻正", "↻正"], ["↔≈匕", "↔≈匕"], ["↔正", "↔正"], ["⿱丶乂", "⿱丶乂"], ["⿺走⿹◰口戈日", "⿺走⿹◰口戈日"], ["≈匚", "≈匚"], ["(⿱北㓁允)", "(⿱北㓁允)"], ["⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人人丨))", "⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人人丨))"], ["⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人人丨))", "⿹弓(⿰(⿱人人丨)(⿱人人丨)(⿱人人丨))"], ["⿰臣(⿱𠂉(⿰人人人)(⿰古古古))", "⿰臣(⿱𠂉(⿰人人人)(⿰古古古))"], ["≈&jzr#xe174;", "≈&jzr#xe174;"], ["(⿱&jzr#xe223;一八⿰(⿱&jzr#xe223;一八)(⿱&jzr#xe223;一八))", "(⿱&jzr#xe223;一八⿰(⿱&jzr#xe223;一八)(⿱&jzr#xe223;一八))"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      ctx = IDLX.parse(probe);
      result = IDLX._tokentree_as_formula(ctx, ctx.tokentree, 'xncr');
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) formula_from_source (1)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["(⿱亠口冖一口十)", "(⿱亠口冖一口十)"], ["(⿱𠚤冖丿&cdp#x88c6;一八)", "(⿱𠚤冖丿&cdp#x88c6;一八)"], ["(⿱卄亠口冖口毛)", "(⿱卄亠口冖口毛)"], ["⿱卄⿰木貝", "⿱卄⿰木貝"], ["⿱艸⿰白⿹&jzr#xe19f;灬", "⿱艸⿰白⿹&jzr#xe19f;灬"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDLX.formula_from_source(probe, 'xncr');
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) formula_from_source (2)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["(⿱亠口冖一口十)", "(⿱亠口冖一口十)"], ["(⿱𠚤冖丿&cdp#x88c6;一八)", "(⿱𠚤冖丿&cdp#x88c6;一八)"], ["(⿱卄亠口冖口毛)", "(⿱卄亠口冖口毛)"], ["⿱卄⿰木貝", "⿱卄⿰木貝"], ["⿱艸⿰白⿹&jzr#xe19f;灬", "⿱艸⿰白⿹灬"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDLX.formula_from_source(probe, 'uchr');
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) sexpr_from_source"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["●", "( ● )"], ["〓", "( 〓 )"], ["▽", "( ▽ )"], ["⿺辶言", "( ⿺ 辶 言 )"], ["⿺辶〓", "( ⿺ 辶 〓 )"], ["⿱癶⿰弓貝", "( ⿱ 癶 ( ⿰ 弓 貝 ) )"], ["⿱⿰亻式貝", "( ⿱ ( ⿰ 亻 式 ) 貝 )"], ["⿱⿰亻式⿱目八", "( ⿱ ( ⿰ 亻 式 ) ( ⿱ 目 八 ) )"], ["≈〇", "( ≈ 〇 )"], ["⿱〓〓", "( ⿱ 〓 〓 )"], ["↻正", "( ↻ 正 )"], ["(⿱亠口冖一口十)", "( ⿱ 亠 口 冖 一 口 十 )"], ["(⿱𠚤冖丿&cdp#x88c6;一八)", "( ⿱ 𠚤 冖 丿 &cdp#x88c6; 一 八 )"], ["(⿱卄亠口冖口毛)", "( ⿱ 卄 亠 口 冖 口 毛 )"], ["⿱卄⿰木貝", "( ⿱ 卄 ( ⿰ 木 貝 ) )"], ["⿱艸⿰白⿹&jzr#xe19f;灬", "( ⿱ 艸 ( ⿰ 白 ( ⿹ &jzr#xe19f; 灬 ) ) )"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDLX.sexpr_from_source(probe, 'xncr');
      urge(CND.grey(probe), CND.lime(result));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(experimental) using arbitrary characters as components"] = function(T) {
    var error, i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [['⿰\\(三\\) )', '( ⿰ \\( 三 \\) )'], ['⿴〇上', '( ⿴ 〇 上 )']];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.sexpr_from_source(probe, 'xncr');
      } catch (error1) {
        error = error1;
        T.fail(error.message);
        continue;
      }
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) doubt mark"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿰魚?𦟝", "( ⿰ 魚 ( ? 𦟝 ) )"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDLX.sexpr_from_source(probe, 'xncr');
      urge(CND.grey(probe), CND.lime(result));
      T.eq(result, matcher);
    }
    return null;
  };

  if (module.parent == null) {
    include = ["(IDL) demo", "sanity checks (grammar data)", "(IDL) parse simple formulas", "(IDL) reject bogus formulas", "(IDL) parse tree of simple formulas", "(IDLX) reject bogus formulas", "(IDLX) reject IDL operators with arity 3", "(IDLX) parse simple formulas", "(IDLX) parse extended formulas (plain)", "(IDLX) parse extended formulas (bracketed)", "(IDLX) reject bogus formulas (bracketed)", "(IDLX) reject bogus formulas (solitaires)", "(IDL) _tokentree_as_formula", "(IDLX) _tokentree_as_formula", "(IDLX) formula_from_source (1)", "(IDLX) formula_from_source (2)", "(IDLX) sexpr_from_source", "(IDLX) doubt mark"];
    this._prune();
    this._main();
    demo_new_api = function() {
      debug(IDLX.diagram_from_source('⿺走日'));
      debug(IDLX.diagram_from_source('(⿱山人儿)'));
      debug(IDLX.diagram_from_source('⿺辶〓'));

      /* 'u-cjk-xb/2a18d' 𪆍 */
      debug(IDLX.diagram_from_source('⿰⿹勹⿱从⿰个个鳥'));
      debug(IDLX.diagram_from_source('⿰⿹勹(⿱从从⿰个个)鳥'));
      debug(IDLX.diagram_from_source('⿰⿹勹(⿱从⿰个个个)鳥'));
      debug();
      debug(IDLX.parse('⿰阝⿱甘罕'));
      debug(IDLX.diagram_from_source('⿰阝⿱甘罕'));
      debug(IDLX.tokenlist_from_source('⿰阝⿱甘罕'));
      return debug(IDLX.tokentree_from_source('⿰阝⿱甘罕'));
    };
    demo_glyph_conversion = function() {
      var glyph, glyph_r1, glyph_r2, glyph_uchr;
      IDL.NCR.jzr_as_xncr = function(glyph) {
        var nfo;
        nfo = this.analyze(glyph);
        if (!((nfo.rsg === 'u-pua') || (nfo.csg === 'jzr'))) {
          return glyph;
        }
        return this.as_chr(nfo.cid, {
          csg: 'jzr'
        });
      };
      glyph = "&jzr#xe234;";
      glyph_uchr = IDL.NCR.jzr_as_uchr(glyph);
      glyph_r1 = IDL.NCR.jzr_as_xncr(glyph);
      glyph_r2 = IDL.NCR.jzr_as_xncr(glyph_uchr);
      debug('32900', [glyph, glyph_uchr, glyph_r1, glyph_r2]);
      return debug('32900', IDL.NCR.jzr_as_xncr('x'));
    };
  }


  /*
  
  need tests for IDL.parse
  
  
  basic version should not use mingkwai-ncr; instead, use
  Steven Levithan's XRegExp to confine valid components to
  non-whitespace, non-meta codepoints
  
  allow meta codepoints as components when escaped?
  
  incorporate full set of JZR IDL operators
  
  IDL algebra
  
  collect operator, component statistics while building the tokentree
   */

}).call(this);

//# sourceMappingURL=tests.js.map
