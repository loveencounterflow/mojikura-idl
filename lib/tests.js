// Generated by CoffeeScript 1.10.0
(function() {
  var CND, IDL, IDLX, MKNCR, alert, badge, debug, demo_errors, echo, help, include, info, log, nice_text_rpr, ref, resume_next, rpr, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MOJIKURA-IDL/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  ref = require('./main'), IDL = ref.IDL, IDLX = ref.IDLX;

  MKNCR = require('mingkwai-ncr');

  nice_text_rpr = function(text) {

    /* Ad-hoc method to print out text in a readable, CoffeeScript-compatible, triple-quoted way. Line breaks
    (`\\n`) will be shown as line breaks, so texts should not be as spaghettified as they appear with
    JSON.stringify (the last line break of a string is, however, always shown in its symbolic form so it
    won't get swallowed by the CoffeeScript parser). Code points below U+0020 (space) are shown as
    `\\x00`-style escapes, taken up less space than `\u0000` escapes while keeping things explicit. All
    double quotes will be prepended with a backslash.
     */
    var R;
    R = text;
    R = R.replace(/[\x00-\x09\x0b-\x19]/g, function($0) {
      var cid_hex;
      cid_hex = ($0.codePointAt(0)).toString(16);
      if (cid_hex.length === 1) {
        cid_hex = '0' + cid_hex;
      }
      return "\\x" + cid_hex;
    });
    R = R.replace(/"/g, '\\"');
    R = R.replace(/\n$/g, '\\n');
    R = '\n"""' + R + '"""';
    return R;
  };

  this._main = function(handler) {
    return test(this, {
      'timeout': 2500
    });
  };

  this._prune = function() {
    var name, value;
    for (name in this) {
      value = this[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  resume_next = function(T, method) {
    var R, error, error1;
    try {
      R = method();
    } catch (error1) {
      error = error1;
      return Symbol("### ERROR ### " + error['message']);
    }
    return R;
  };

  this["sanity checks (private methods)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"]], ["⿲", ["assigned", "cjk", "idl"]], ["a", ["assigned"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDL._tags_from_symbol(null, probe);
      help(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["sanity checks (grammar data)"] = function(T) {
    T.ok('⿰' in IDL.grammar.operators);
    T.ok('⿱' in IDL.grammar.operators);
    T.ok('⿴' in IDL.grammar.operators);
    T.ok('⿵' in IDL.grammar.operators);
    T.ok('⿶' in IDL.grammar.operators);
    T.ok('⿷' in IDL.grammar.operators);
    T.ok('⿸' in IDL.grammar.operators);
    T.ok('⿹' in IDL.grammar.operators);
    T.ok('⿺' in IDL.grammar.operators);
    T.ok('⿻' in IDL.grammar.operators);
    T.ok('⿲' in IDL.grammar.operators);
    T.ok('⿳' in IDL.grammar.operators);
    T.ok('⿰' in IDLX.grammar.operators);
    T.ok('⿱' in IDLX.grammar.operators);
    T.ok('⿴' in IDLX.grammar.operators);
    T.ok('⿵' in IDLX.grammar.operators);
    T.ok('⿶' in IDLX.grammar.operators);
    T.ok('⿷' in IDLX.grammar.operators);
    T.ok('⿸' in IDLX.grammar.operators);
    T.ok('⿹' in IDLX.grammar.operators);
    T.ok('⿺' in IDLX.grammar.operators);
    T.ok('⿻' in IDLX.grammar.operators);
    T.ok(!('⿲' in IDLX.grammar.operators));
    T.ok(!('⿳' in IDLX.grammar.operators));
    T.ok('◰' in IDLX.grammar.operators);
    T.ok('≈' in IDLX.grammar.operators);
    T.ok('↻' in IDLX.grammar.operators);
    T.ok('↔' in IDLX.grammar.operators);
    T.ok('↕' in IDLX.grammar.operators);
    T.ok('●' in IDLX.grammar.solitaires);
    T.ok(IDL.grammar !== IDLX.grammar);
    T.ok(IDL.grammar.operators !== IDLX.grammar.operators);
    T.ok(!CND.equals(IDL.grammar, IDLX.grammar));
    T.ok(!CND.equals(IDL.grammar.operators, IDLX.grammar.operators));
    return null;
  };

  this["sanity checks (MKNCR)"] = function(T) {
    var csg, description, i, len, matcher, probe, probes_and_matchers, ref1, result, tag;
    probes_and_matchers = [["⿲", ["u", ["assigned", "cjk", "idl"]]], ["木", ["u", ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"]]], ["&#x1234;", ["u", ["assigned"]]], ["&#xe100;", ["u", ["assigned", "pua", "cjk"]]], ["&jzr#xe100;", ["jzr", ["assigned", "cjk"]]], ["&morohashi#x1234;", ["morohashi", ["assigned", "cjk"]]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      description = MKNCR.describe(probe);
      csg = description.csg, tag = description.tag;
      result = [csg, tag];
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) parse simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿲木木木", ["⿲", "木", "木", "木"]], ["⿱癶⿰弓貝", ["⿱", "癶", ["⿰", "弓", "貝"]]], ["⿱⿰亻式貝", ["⿱", ["⿰", "亻", "式"], "貝"]], ["⿱⿰亻式⿱目八", ["⿱", ["⿰", "亻", "式"], ["⿱", "目", "八"]]], ["⿺辶言", ["⿺", "辶", "言"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDL.parse(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) parse tree of simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [
      [
        "⿲木木木", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿲",
            "idx": 0,
            "t": "operator",
            "a": 3,
            "n": "pillars"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 1,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 2,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "木",
            "idx": 3,
            "t": "component"
          }
        ]
      ], [
        "⿱癶⿰弓貝", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "癶",
            "idx": 1,
            "t": "component"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 2,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "弓",
              "idx": 3,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "貝",
              "idx": 4,
              "t": "component"
            }
          ]
        ]
      ], [
        "⿱⿰亻式貝", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 1,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "亻",
              "idx": 2,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "式",
              "idx": 3,
              "t": "component"
            }
          ], {
            "~isa": "MOJIKURA-IDL/token",
            "s": "貝",
            "idx": 4,
            "t": "component"
          }
        ]
      ], [
        "⿱⿰亻式⿱目八", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿱",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "top/down"
          }, [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿰",
              "idx": 1,
              "t": "operator",
              "a": 2,
              "n": "left-right"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "亻",
              "idx": 2,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "式",
              "idx": 3,
              "t": "component"
            }
          ], [
            {
              "~isa": "MOJIKURA-IDL/token",
              "s": "⿱",
              "idx": 4,
              "t": "operator",
              "a": 2,
              "n": "top/down"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "目",
              "idx": 5,
              "t": "component"
            }, {
              "~isa": "MOJIKURA-IDL/token",
              "s": "八",
              "idx": 6,
              "t": "component"
            }
          ]
        ]
      ], [
        "⿺辶言", [
          {
            "~isa": "MOJIKURA-IDL/token",
            "s": "⿺",
            "idx": 0,
            "t": "operator",
            "a": 2,
            "n": "leftbottom"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "辶",
            "idx": 1,
            "t": "component"
          }, {
            "~isa": "MOJIKURA-IDL/token",
            "s": "言",
            "idx": 2,
            "t": "component"
          }
        ]
      ]
    ];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDL.parse_tree(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) reject bogus formulas"] = function(T) {
    var error, error1, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", "syntax error: lone token of type 'component' in [  ✘ 木 ✘  ]"], [42, "expected a text, got a number"], ["", "syntax error: empty text"], ["⿱⿰亻式⿱目八木木木", "syntax error: extra token(s) in [ ⿱⿰亻式⿱目八 ✘ 木 ✘ 木木 ]"], ["⿺廴聿123", "syntax error: extra token(s) in [ ⿺廴聿 ✘ 1 ✘ 23 ]"], ["⿺", "syntax error: premature end of source in [  ✘ ⿺ ✘  ])"], ["⿺⿺⿺⿺", "syntax error: premature end of source in [ ⿺⿺⿺ ✘ ⿺ ✘  ])"], ["⿺12", "syntax error: illegal token '1' (type 'other') in [ ⿺ ✘ 1 ✘ 2 ]"], ["(⿰亻聿式)", "syntax error: illegal token '(' (type 'other') in [  ✘ ( ✘ ⿰亻聿式) ]"], ["≈〇", "syntax error: illegal token '≈' (type 'other') in [  ✘ ≈ ✘ 〇 ]"], ["●", "syntax error: illegal token '●' (type 'other') in [  ✘ ● ✘  ]"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDL.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
        T.eq(message, matcher);
      }
    }
    return null;
  };

  this["(IDLX) parse simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿱癶⿰弓貝", ["⿱", "癶", ["⿰", "弓", "貝"]]], ["⿱⿰亻式貝", ["⿱", ["⿰", "亻", "式"], "貝"]], ["⿱⿰亻式⿱目八", ["⿱", ["⿰", "亻", "式"], ["⿱", "目", "八"]]], ["⿺辶言", ["⿺", "辶", "言"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDLX.parse(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) reject bogus formulas"] = function(T) {
    var error, error1, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", "syntax error: lone token of type 'component' in [  ✘ 木 ✘  ]"], [42, "expected a text, got a number"], ["", "syntax error: empty text"], ["⿱⿰亻式⿱目八木木木", "syntax error: extra token(s) in [ ⿱⿰亻式⿱目八 ✘ 木 ✘ 木木 ]"], ["⿺廴聿123", "syntax error: extra token(s) in [ ⿺廴聿 ✘ 1 ✘ 23 ]"], ["⿺", "syntax error: premature end of source in [  ✘ ⿺ ✘  ])"], ["⿺⿺⿺⿺", "syntax error: premature end of source in [ ⿺⿺⿺ ✘ ⿺ ✘  ])"], ["⿺12", "syntax error: illegal token '1' (type 'other') in [ ⿺ ✘ 1 ✘ 2 ]"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
        T.eq(message, matcher);
      }
    }
    return null;
  };

  this["(IDLX) reject IDL operators with arity 3"] = function(T) {
    var error, error1, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿲木木木", "syntax error: extra token(s) in [ ⿲ ✘ 木 ✘ 木木 ]"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
        T.eq(message, matcher);
      }
    }
    return null;
  };

  this["(IDLX) parse extended formulas (plain)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [['≈㐀', ['≈', '㐀']], ['≈𠀎', ['≈', '𠀎']], ['≈𪜀', ['≈', '𪜀']], ['≈〇', ['≈', '〇']], ['●', '●'], ['〓', '〓'], ['⿱〓〓', ['⿱', '〓', '〓']], ['▽', '▽'], ['↻正', ['↻', '正']], ['↔≈匕', ['↔', ['≈', '匕']]], ['↔正', ['↔', '正']], ['⿱丶乂', ['⿱', '丶', '乂']], ['⿺走⿹◰口戈日', ['⿺', '走', ['⿹', ['◰', '口', '戈'], '日']]], ['≈匚', ['≈', '匚']], ["≈&jzr#xe174;", ["≈", ""]], ['≈非', ['≈', '非']], ['⿺走⿹◰口〓日', ['⿺', '走', ['⿹', ['◰', '口', '〓'], '日']]], ["⿻串⿰立&jzr#x1234;", ["⿻", "串", ["⿰", "立", "ሴ"]]], ["⿱丶⿵𠘨§", ["⿱", "丶", ["⿵", "𠘨", "§"]]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = resume_next(T, function() {
        return IDLX.parse(probe);
      });
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) parse extended formulas (bracketed)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [['⿰亻聿', ['⿰', '亻', '聿']], ['(⿰亻聿式)', ['⿰', '亻', '聿', '式']]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDLX.parse(probe);
      urge(JSON.stringify([probe, result]));
    }
    return null;
  };

  this["(IDLX) reject bogus bracketed formulas"] = function(T) {
    var error, error1, i, len, matcher, message, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [['(⿰亻聿)', ""], ['(⿰亻)', ""], ['(⿰亻)聿', ""]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        message = CND.remove_colors(error['message']);
        warn(JSON.stringify([probe, message]));
      }
    }
    return null;
  };

  if (module.parent == null) {
    include = ["sanity checks (private methods)", "sanity checks (grammar data)", "sanity checks (MKNCR)", "(IDL) parse simple formulas", "(IDL) reject bogus formulas", "(IDL) parse tree of simple formulas", "(IDLX) reject bogus formulas", "(IDLX) reject IDL operators with arity 3", "(IDLX) parse simple formulas", "(IDLX) parse extended formulas (plain)", "(IDLX) parse extended formulas (bracketed)"];
    this._prune();
    this._main();
    info(IDLX.parse('⿰亻聿'));
    info(IDLX.parse('(⿰亻聿式)'));
    demo_errors = function() {
      var d, error, error1, i, len, results, source, sources;
      sources = ["", "⿺", "走", "走⿹◰口弓戈〓", "⿺走x", "⿺走⿹◰口弓戈〓"];
      results = [];
      for (i = 0, len = sources.length; i < len; i++) {
        source = sources[i];
        try {
          results.push(d = IDLX.parse_tree(source));
        } catch (error1) {
          error = error1;
          results.push(info(error['message']));
        }
      }
      return results;
    };
  }


  /*
  
  
  use PipeDreams tap to implement benchmarks
  
  detect bogus occurrences of solitaires in non-minimal formulas
  
  remove stack and other unused properties of _new_parse
  
  implement brackets
   */

}).call(this);

//# sourceMappingURL=tests.js.map
