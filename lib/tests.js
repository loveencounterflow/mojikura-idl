// Generated by CoffeeScript 1.10.0
(function() {
  var CND, IDL, alert, badge, debug, echo, help, include, info, join, log, nice_text_rpr, njs_path, rpr, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  njs_path = require('path');

  join = njs_path.join;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MOJIKURA-IDL/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  IDL = require('./main');

  nice_text_rpr = function(text) {

    /* Ad-hoc method to print out text in a readable, CoffeeScript-compatible, triple-quoted way. Line breaks
    (`\\n`) will be shown as line breaks, so texts should not be as spaghettified as they appear with
    JSON.stringify (the last line break of a string is, however, always shown in its symbolic form so it
    won't get swallowed by the CoffeeScript parser). Code points below U+0020 (space) are shown as
    `\\x00`-style escapes, taken up less space than `\u0000` escapes while keeping things explicit. All
    double quotes will be prepended with a backslash.
     */
    var R;
    R = text;
    R = R.replace(/[\x00-\x09\x0b-\x19]/g, function($0) {
      var cid_hex;
      cid_hex = ($0.codePointAt(0)).toString(16);
      if (cid_hex.length === 1) {
        cid_hex = '0' + cid_hex;
      }
      return "\\x" + cid_hex;
    });
    R = R.replace(/"/g, '\\"');
    R = R.replace(/\n$/g, '\\n');
    R = '\n"""' + R + '"""';
    return R;
  };

  this._main = function(handler) {
    return test(this, {
      'timeout': 2500
    });
  };

  this._prune = function() {
    var name, value;
    for (name in this) {
      value = this[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  this["demo"] = function(T) {
    var i, len, p, source, sources;
    sources = ['木', '⿲木木木', '⿱癶⿰弓貝', '⿱⿰亻式貝', '⿱⿰亻式⿱目八', '⿺辶言'];
    for (i = 0, len = sources.length; i < len; i++) {
      source = sources[i];
      help(source);
      p = IDL.parse(source);
      urge(JSON.stringify(p));
    }
    return null;
  };

  this["parse simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref, result;
    probes_and_matchers = [["木", "木"], ["⿲木木木", ["⿲", "木", "木", "木"]], ["⿱癶⿰弓貝", ["⿱", "癶", ["⿰", "弓", "貝"]]], ["⿱⿰亻式貝", ["⿱", ["⿰", "亻", "式"], "貝"]], ["⿱⿰亻式⿱目八", ["⿱", ["⿰", "亻", "式"], ["⿱", "目", "八"]]], ["⿺辶言", ["⿺", "辶", "言"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
      result = IDL.parse(probe);
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["reject bogus formulas"] = function(T) {
    var error, error1, i, len, matcher, probe, probes_and_matchers, ref, result;
    probes_and_matchers = [[42, "expected a text, got a number"], ["", "syntax error (empty text)"], ["⿱⿰亻式⿱目八木木木", "syntax error (token idx 7 of '⿱⿰亻式⿱目八木木木')"], ["⿺廴聿123", "syntax error (token idx 3 of '⿺廴聿123')"], ["⿺", "syntax error (premature end of source '⿺')"], ["⿺⿺⿺⿺", "syntax error (premature end of source '⿺⿺⿺⿺')"], ["⿺12", "unable to parse token of type other (token idx 2 of '⿺12')"], ["(⿰亻聿式)", "unable to parse token of type other (token idx 1 of '(⿰亻聿式)')"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
      try {
        result = IDL.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        warn(JSON.stringify([probe, error['message']]));
        T.eq(error['message'], matcher);
      }
    }
    return null;
  };

  if (module.parent == null) {
    include = ["parse simple formulas", "reject bogus formulas"];
    this._prune();
    this._main();
  }

}).call(this);

//# sourceMappingURL=tests.js.map
