// Generated by CoffeeScript 1.10.0
(function() {
  var CND, IDL, IDLX, alert, badge, debug, echo, help, include, info, log, nice_text_rpr, ref, rpr, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MOJIKURA-IDL/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  ref = require('./main'), IDL = ref.IDL, IDLX = ref.IDLX;

  nice_text_rpr = function(text) {

    /* Ad-hoc method to print out text in a readable, CoffeeScript-compatible, triple-quoted way. Line breaks
    (`\\n`) will be shown as line breaks, so texts should not be as spaghettified as they appear with
    JSON.stringify (the last line break of a string is, however, always shown in its symbolic form so it
    won't get swallowed by the CoffeeScript parser). Code points below U+0020 (space) are shown as
    `\\x00`-style escapes, taken up less space than `\u0000` escapes while keeping things explicit. All
    double quotes will be prepended with a backslash.
     */
    var R;
    R = text;
    R = R.replace(/[\x00-\x09\x0b-\x19]/g, function($0) {
      var cid_hex;
      cid_hex = ($0.codePointAt(0)).toString(16);
      if (cid_hex.length === 1) {
        cid_hex = '0' + cid_hex;
      }
      return "\\x" + cid_hex;
    });
    R = R.replace(/"/g, '\\"');
    R = R.replace(/\n$/g, '\\n');
    R = '\n"""' + R + '"""';
    return R;
  };

  this._main = function(handler) {
    return test(this, {
      'timeout': 2500
    });
  };

  this._prune = function() {
    var name, value;
    for (name in this) {
      value = this[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  this["(IDL) demo"] = function(T) {
    var i, len, p, source, sources;
    sources = ['木', '⿲木木木', '⿱癶⿰弓貝', '⿱⿰亻式貝', '⿱⿰亻式⿱目八', '⿺辶言'];
    for (i = 0, len = sources.length; i < len; i++) {
      source = sources[i];
      help(source);
      p = IDL.parse(source);
      urge(JSON.stringify(p));
    }
    return null;
  };

  this["(IDL) sanity checks (private methods)"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"]], ["⿲", ["assigned", "cjk", "idl"]], ["a", ["assigned"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDL._tags_from_symbol(null, probe);
      help(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) sanity checks (grammar data)"] = function(T) {
    T.ok('⿰' in IDL.grammar.operators);
    T.ok('⿱' in IDL.grammar.operators);
    T.ok('⿴' in IDL.grammar.operators);
    T.ok('⿵' in IDL.grammar.operators);
    T.ok('⿶' in IDL.grammar.operators);
    T.ok('⿷' in IDL.grammar.operators);
    T.ok('⿸' in IDL.grammar.operators);
    T.ok('⿹' in IDL.grammar.operators);
    T.ok('⿺' in IDL.grammar.operators);
    T.ok('⿻' in IDL.grammar.operators);
    T.ok('⿲' in IDL.grammar.operators);
    T.ok('⿳' in IDL.grammar.operators);
    T.ok('⿰' in IDLX.grammar.operators);
    T.ok('⿱' in IDLX.grammar.operators);
    T.ok('⿴' in IDLX.grammar.operators);
    T.ok('⿵' in IDLX.grammar.operators);
    T.ok('⿶' in IDLX.grammar.operators);
    T.ok('⿷' in IDLX.grammar.operators);
    T.ok('⿸' in IDLX.grammar.operators);
    T.ok('⿹' in IDLX.grammar.operators);
    T.ok('⿺' in IDLX.grammar.operators);
    T.ok('⿻' in IDLX.grammar.operators);
    T.ok(!('⿲' in IDLX.grammar.operators));
    T.ok(!('⿳' in IDLX.grammar.operators));
    T.ok('◰' in IDLX.grammar.operators);
    T.ok('≈' in IDLX.grammar.operators);
    T.ok('↻' in IDLX.grammar.operators);
    T.ok('↔' in IDLX.grammar.operators);
    T.ok('↕' in IDLX.grammar.operators);
    return null;
  };

  this["(IDL) parse simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", "木"], ["⿲木木木", ["⿲", "木", "木", "木"]], ["⿱癶⿰弓貝", ["⿱", "癶", ["⿰", "弓", "貝"]]], ["⿱⿰亻式貝", ["⿱", ["⿰", "亻", "式"], "貝"]], ["⿱⿰亻式⿱目八", ["⿱", ["⿰", "亻", "式"], ["⿱", "目", "八"]]], ["⿺辶言", ["⿺", "辶", "言"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDL.parse(probe);
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDL) reject bogus formulas"] = function(T) {
    var error, error1, i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [[42, "expected a text, got a number"], ["", "syntax error (empty text)"], ["⿱⿰亻式⿱目八木木木", "syntax error (token idx 7 of '⿱⿰亻式⿱目八木木木')"], ["⿺廴聿123", "syntax error (token idx 3 of '⿺廴聿123')"], ["⿺", "syntax error (premature end of source '⿺')"], ["⿺⿺⿺⿺", "syntax error (premature end of source '⿺⿺⿺⿺')"], ["⿺12", "unable to parse token of type other (token idx 2 of '⿺12')"], ["(⿰亻聿式)", "unable to parse token of type other (token idx 1 of '(⿰亻聿式)')"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDL.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        warn(JSON.stringify([probe, error['message']]));
        T.eq(error['message'], matcher);
      }
    }
    return null;
  };

  this["(IDLX) parse simple formulas"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["木", "木"], ["⿱癶⿰弓貝", ["⿱", "癶", ["⿰", "弓", "貝"]]], ["⿱⿰亻式貝", ["⿱", ["⿰", "亻", "式"], "貝"]], ["⿱⿰亻式⿱目八", ["⿱", ["⿰", "亻", "式"], ["⿱", "目", "八"]]], ["⿺辶言", ["⿺", "辶", "言"]]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      result = IDLX.parse(probe);
      urge(JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["(IDLX) reject bogus formulas"] = function(T) {
    var error, error1, i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [[42, "expected a text, got a number"], ["", "syntax error (empty text)"], ["⿱⿰亻式⿱目八木木木", "syntax error (token idx 7 of '⿱⿰亻式⿱目八木木木')"], ["⿺廴聿123", "syntax error (token idx 3 of '⿺廴聿123')"], ["⿺", "syntax error (premature end of source '⿺')"], ["⿺⿺⿺⿺", "syntax error (premature end of source '⿺⿺⿺⿺')"], ["⿺12", "unable to parse token of type other (token idx 2 of '⿺12')"], ["(⿰亻聿式)", "unable to parse token of type other (token idx 1 of '(⿰亻聿式)')"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        warn(JSON.stringify([probe, error['message']]));
        T.eq(error['message'], matcher);
      }
    }
    return null;
  };

  this["(IDLX) reject IDL operators with arity 3"] = function(T) {
    var error, error1, i, len, matcher, probe, probes_and_matchers, ref1, result;
    probes_and_matchers = [["⿲木木木", "syntax error (token idx 1 of '⿲木木木')"]];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref1 = probes_and_matchers[i], probe = ref1[0], matcher = ref1[1];
      try {
        result = IDLX.parse(probe);
        T.fail("expected an exception, got result " + (rpr(result)));
      } catch (error1) {
        error = error1;
        warn(JSON.stringify([probe, error['message']]));
        T.eq(error['message'], matcher);
      }
    }
    return null;
  };

  if (module.parent == null) {
    include = ["(IDL) sanity checks (private methods)", "(IDL) parse simple formulas", "(IDL) reject bogus formulas", "(IDLX) parse simple formulas", "(IDLX) reject bogus formulas", "(IDLX) reject IDL operators with arity 3", "(IDL) sanity checks (grammar data)"];
    this._prune();
    this._main();
  }

}).call(this);

//# sourceMappingURL=tests.js.map
